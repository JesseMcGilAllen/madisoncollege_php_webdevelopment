<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta name="generator" content="HTML Tidy, see www.w3.org">
  <title>Using Files</title>
  <link href="../../../css/basic.css" rel="stylesheet" type="text/css">
  <script type="text/javascript" language="JavaScript">
<!--
function putSemester() {
    var today=new Date();
    var thisMonth=today.getMonth()+1;
    var thisYear=today.getFullYear();
    if(thisMonth <=6) {
        return "Spring, " + thisYear;
    }
    else {
       return "Fall, " + thisYear;
    }
}//-->
  </script>
  <style type="text/css">
<!--
    .bgStripes {
        background-image:url(../../../images/Xstripes.gif);
        background-attachment: fixed;
    }
    body {
        background-color:white;
    }
    strong {
        font-family: Arial, Helvetica, sans-serif;
    }
    .table1 {
        font-family:Arial, Helvetica, sans-serif;
        font-size: small;
    }
    .table2 {
        font-family:Arial, Helvetica, sans-serif;
        font-size: small;
        text-align:center;
    }
    td.cen {
        text-align:center;
    }
    .small_title {
        font-family: Arial, Helvetica, sans-serif;
        font-size:x-small;
        font-weight:bold;
    }
    .med_title {
        font-family: Arial, Helvetica, sans-serif;
        font-size:medium;
        font-weight:bold;
        text-align:center;
        color:darkblue;
    }
    -->
  </style>
</head>
<body bgcolor="#ffffff" text="#000000">
<table class="bgStripes" border="0" width="100%">
      <tbody>
    <tr name="firstRow">
        <td valign="top" width="80">

      <p class="small_title">
      
      
      <script type="text/javascript">
          <!--
            document.write(putSemester());
            -->
      </script>
          </p>
        </td>
        <td>

      <p class="med_title"><span style="color: darkblue; font-size: medium; font-weight: bold;">PHP
and
MySQL Development</span></p>
        </td>
        <td align="right" valign="top" width="80">

      <p class="small_title">3 Credits</p>
        </td>
      </tr>
      <tr>
        <td colspan="3" height="10">

      <p class="small_title" align="center">152-166</p>
        </td>
      </tr>
  </tbody>
</table>
    <!--The heading for the slides -->
    <br>
     
<table class="headTable1" border="0">
      <tbody>
    <tr>
        <td width="100"><a href="data.html"><img alt="" src="../../../images/btn_lArrow.gif" border="0"></a><a href="index.html"><img alt="" src="../../../images/btn_upArrow.gif" border="0"></a><a href="readfl.html"><img alt="" src="../../../images/btn_rArrow.gif" border="0"></a></td>
        <td>

      <p>Opening, Writing and Closing Files</p>
        </td>
      </tr>
  </tbody>
</table>
    <br>
<div class="disp1">
<ul class="slidesUl1">
  <li>
    <p>Opening a
File</p>
<p>To open a file in PHP, you use the <code>fopen()</code> function.
When you open the file, you
need to specify how you intend to use it.
This is known as the file mode.</p>
  </li>
  <li>
    <p>Choosing File
Modes</p>
    <p>The operating system on the server needs to know what you want to do
with a file that you are opening.
It needs to know whether the file can be opened by
another script while you have it open and whether you
(or the script owner) have permission to use
it in that way. Essentially, file modes give the operating system a
mechanism to
determine how to handle access requests from other people or scripts and a method
to check
that you have access and permission to a particular
file.</p>
<p>
You need to make three choices when opening a file:</p>
</ul>
<blockquote>
<ol type="1">
<li class="row1">
You might want to open a file for reading only, for writing only, or
for both reading and writing.
</li>
<li class="row1">
If writing to a file, you might want to overwrite any existing
contents of a file or append new data to the end of the file.
You also might like to terminate
your program gracefully instead of overwriting a file if the file already
exists.
</li>
<li class="row1">
If you are trying to write to a file on a system that
differentiates between binary and text files, you might want to specify
this fact.
</li>
</ol>
</blockquote>
<ul class="slidesUl1">
<p>
The <code>fopen()</code> function supports combinations of these three options.
</p>
  </li>
  <li>
<p>Using fopen() to Open a File</p>
    <p>
Assume that you want to write a customer order to Bob's order
file. You can open this file for writing with the following:</p>
<code>
&nbsp;&nbsp;$fp = fopen("$DOCUMENT_ROOT/../orders/orders.txt", 'w');<br>
</code>
    <p>
When <code>fopen()</code> is called, it expects two, three,
or four parameters.
Usually, you use two, as shown in this code line.</p>
    <p>
The first parameter should be the file you want to open. You can specify
a path to this file, as in the preceding code. Here, the orders.txt file is in the
orders directory.
We used the PHP built-in variable <code>$_SERVER['DOCUMENT_ROOT']</code> but, as with
the cumbersome full names for form variables, we assigned a shorter name.</p>
    <p>
This variable points at the base of the document tree on your web
server. This code line uses .. to mean "the parent directory of the document root
directory." This directory is outside the document tree, for security reasons.
In this case, we do not want this file to be web accessible except through the
interface that we provide. This
path is called a relative path because it describes a position in the file system
relative to the document root.</p>
    <p>
As with the short names given form variables, you need the following
line at the start of your script:</p>
<code>
&nbsp;&nbsp;$DOCUMENT_ROOT = $_SERVER['DOCUMENT_ROOT'];<br>
</code>
    <p>
to copy the contents of the long-style variable to the short-style name.</p>
    <p>
Just as there are different ways to access form data, there are
different ways to access the predefined server variables.
Depending on your server setup you can get at the document root through:</p>
<blockquote><code>
$_SERVER['DOCUMENT_ROOT']<br>
<br>
$DOCUMENT_ROOT<br>
<br>
$HTTP_SERVER_VARS['DOCUMENT_ROOT']<br>
</code></blockquote>
    <p>
As with form data, the first style is preferred.</p>
    <p>
You could also specify an absolute path to the file. This is the path from
the root directory (/ on a Unix system and typically C:\ on a Windows system).
On our Unix server, this path would be <code>/home/book/orders</code> .
The problem with using this approach is that,
particularly if you are hosting your site on somebody else's
server, the absolute path might change.
We once learned this the hard way after having to change
absolute paths in a large number of scripts when the system administrators decided to
change the directory structure without notice.</p>
    <p>
If no path is specified, the file will be created or looked for in the
same directory as the script itself.
The directory used will vary if you are running PHP
through some kind of CGI wrapper and depends on your server configuration.
    </p>
    <p>
In a Unix environment, you use forward slashes (/) in directory
paths. If you are using a Windows platform, you can use forward (/) or
backslashes (\). If you use
backslashes, they must be escaped (marked as a special character) for
<code>fopen()</code> to understand them properly.
To escape a character, you simply add an additional
backslash in front of it, as shown in the following:</p>
<code><small>
&nbsp;&nbsp;$fp = fopen("$DOCUMENT_ROOT\\..\\orders\\orders.txt", 'w');<br>
</small></code>
    <p>
Very few people use backslashes in paths in PHP because it means
the code will work only in Windows environments.
If you use forward slashes, you can often
move your code between Windows and Unix machines without alteration.</p>
    <p>
The second <code>fopen()</code> parameter is the file mode,
which should be a string. This
string specifies what you want to do with the file. In this case, we are
passing 'w' to <code>fopen()</code> .
This means "open the file for writing."
A summary of file modes is shown below:</p>
<code><small>
<span style="text-decoration: underline;">Mode&nbsp;
Mode Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Meaning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
<br>
&nbsp;r&nbsp;&nbsp;&nbsp;
Read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open the file for reading, beginning from the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
start of the file.<br>
&nbsp;r+&nbsp;&nbsp;
Read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open the file for reading and writing, beginning<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
from the start of the file.<br>
&nbsp;w&nbsp;&nbsp;&nbsp;
Write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open the file for writing, beginning from the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
start of the file. If the file already exists,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
delete the existing contents. If it does not <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exist, try to create it.<br>
&nbsp;w+&nbsp;&nbsp;
Write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open the file for writing and reading, beginning<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
from the start of the file. If the file already<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exists, delete the existing contents. If it does<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
not exist, try to create it.<br>
&nbsp;x&nbsp;&nbsp;&nbsp;
Cautious write&nbsp;&nbsp;&nbsp;
Open the file for writing, beginning from the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
start of the file. If the file already exists,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
it will not be opened, fopen() will return false,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and PHP will generate a warning.<br>
&nbsp;x+&nbsp;&nbsp;
Cautious write&nbsp;&nbsp;&nbsp;
Open the file for writing and reading, beginning<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
from the start of the file. If the file already<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exists, it will not be opened, fopen() will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return false, and PHP will generate a warning.<br>
&nbsp;a&nbsp;&nbsp;&nbsp;
Append&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open the file for appending (writing) only,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
starting from the end of the existing contents,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if any. If it does not exist, try to create it.<br>
&nbsp;a+&nbsp;&nbsp;
Append&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open the file for appending (writing) and reading,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
starting from the end of the existing contents,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if any. If it does not exist, try to create it.<br>
&nbsp;b&nbsp;&nbsp;&nbsp;
Binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Used in conjunction with one of the other modes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
You might want to use this mode if your file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
system differentiates between binary and text<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
files. Windows systems differentiate; Unix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
systems do not. The PHP developers recommend you<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
always use this option for maximum portability.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
It is the default mode.<br>
&nbsp;t&nbsp;&nbsp;&nbsp;
Text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Used in conjunction with one of the other modes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This mode is an option only in Windows systems.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
It is not recommended except before you have<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ported your code to work with the "b" option.<br>
</small></code>
    <p>
The file mode you use in the example depends on how the system will be used.
We used 'w', which allows only one order to be stored in the file.
Each time a new order is taken, it overwrites the previous order.
This usage is probably not very sensible, so you would better off specifying
append mode (and binary mode, as recommended):</p>
<code>
&nbsp;&nbsp;$fp = fopen("$DOCUMENT_ROOT/../orders/orders.txt", 'ab');<br>
</code>
    <p>
The third parameter of <code>fopen()</code> is optional.
You can use it if you want to search the <code>include_path</code>
- set in your PHP configuration file, php.ini - for a file.
If you want to do this, set this parameter to "1" (one).
If you tell PHP to search the include_path, you do not need to provide a
directory name or path:</p>
<code>
&nbsp;&nbsp;$fp = fopen('orders.txt', 'ab', true);<br>
</code>
    <p>
The fourth parameter is also optional. The <code>fopen()</code> function
allows filenames to be prefixed with a protocol (such as "http://") and
opened at a remote location.
Some protocols allow for an extra parameter.
We look at this use of the <code>fopen()</code> function in the next section.</p>
    <p>
If <code>fopen()</code> opens the file successfully, a resource that is
effectively a pointer to the file is returned and should be stored in a
variable - in this case, <code>$fp</code> .
You use this variable to access the file when you actually want to read from
or write to it.</p>
  </li>
  <li>
    <p>
Opening Files Through FTP or HTTP</p>
    <p>
In addition to opening local files for reading and writing, you can
open files via FTP, HTTP, and other protocols using <code>fopen()</code> .
You can disable this capability by turning off the <code>allow_url_fopen</code>
directive in the php.ini file.
If you have trouble opening remote files with <code>fopen()</code> ,
check your php.ini file.</p>
    <p>
If the filename you use begins with "ftp://", a passive mode FTP
connection will be opened to the server you specify
and a pointer to the start of the file will be returned.</p>
    <p>
If the filename you use begins with "http://", an HTTP connection
will be opened to the server you specify and a pointer to the response
will be returned. When using HTTP mode with older versions of PHP,
you must specify trailing slashes on directory names,
as shown in the following:</p>
<blockquote><code>
http://www.example.com/<br>
</code></blockquote>
<p>not</p>
<blockquote><code>
http://www.example.com<br>
</code></blockquote>
    <p>
When you specify the latter form of address (without the slash),
a web server normally uses an HTTP redirect to send you to the first address
(with the slash). Try it in your browser.
    </p>
    <p>
Prior to PHP 4.0.5, the <code>fopen()</code> function did not support HTTP redirects,
so you had to specify URLs that referred to directories with a trailing
slash.</p>
    <p>
As of PHP 4.3.0, you can now open files over SSL as long as you have compiled
or enabled support for OpenSSL and you begin the name of the file with "https://".</p>
    <p>
Remember that the domain names in your URL are not case sensitive, but the
path and filename might be.</p>
  </li>
  <li>
    <p>
Addressing Problems Opening Files</p>
    <p>
An error you might make is trying to open a file you do not have permission
to read from or write to.
(This error occurs commonly on Unix-like operating
systems, but also see it occasionally under Windows.)
When you do, PHP gives you a warning similar to:</p>
<code><small>
Warning: fopen(c:/program files/apache group/apache/htdocs/../orders/orders.txt)<br>
[function.fopen]: failed to open stream: Permission denied in<br>
c:\program files\apache group\Apache\htdocs\phpmysql\ch02\processorder.php on line 63<br>
</small></code>
    <p>
If you receive this error, you need to make sure that the user under which the
script runs has permission to access the file you are trying to use.
Depending on how your server is set up,
the script might be running as the web server user or as the owner
of the directory where the script is located.
    </p>
    <p>
On most systems, the script runs as the web server user.
If your script is on a Unix system in the <code>~/public_html/unit3/</code>
directory, for example,
you could create a world-writeable directory in which to store
the order by typing the following:</p>
<blockquote><code>
mkdir ~/orders<br>
chmod 777 ~/orders<br>
</code></blockquote>
    <p>
Bear in mind that directories and files that anybody can write to are dangerous.
In particular, directories that are accessible directly from the Web should
not be writeable. For this reason, our orders directory is two subdirectories back,
above the public_html directory.</p>
    <p>
Incorrect permission setting is probably the most common thing that can
go wrong when opening a file, but it is not the only thing.
If you are unable to open the file, you really need to know this so that
you do not try to read data from or write data to it.</p>
    <p>
If the call to <code>fopen()</code> fails, the function will return false.
You can deal with the error in a more user-friendly way by suppressing
PHP's error message and giving your own:</p>
<blockquote><code>
@ $fp = fopen("$DOCUMENT_ROOT/../orders/orders.txt", 'ab');<br>
if (!$fp)<br>
{<br>
&nbsp;&nbsp;echo '&lt;p&gt;&lt;strong&gt; Your order could not be processed at this time.'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. 'Please try again later.&lt;/strong&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;';<br>
&nbsp;&nbsp;exit;<br>
}<br>
</code></blockquote>
    <p>
The "@" symbol in front of the call to <code>fopen()</code> tells PHP to
suppress any errors resulting from the function call.
Usually, it is a good idea to know when things go wrong,
but in this case we are going to deal with that problem elsewhere.</p>
    <p>
You can also write this line as follows:</p>
<blockquote><code>
$fp = @fopen("$DOCUMENT_ROOT/../orders/orders.txt", 'a');<br>
</code></blockquote>
    <p>
Using this method tends to make it less obvious that you are using the
error suppression operator, so it may make your code harder to debug.</p>
    <p>
The method described here is a simplistic way of dealing with errors.
We look at a more elegant method for error handling later in the course.
But one thing at a time.</p>
    <p>
The if statement tests the variable <code>$fp</code> to see whether a valid
file pointer was returned from the fopen call;
if not, it prints an error message and ends script execution.
Because the page finishes here, notice that we have closed the HTML
tags to give reasonably valid HTML.</p>
  </li>
  <li>
<p>
Writing to a File</p>
    <p>
Writing to a file in PHP is relatively simple. You can use either of the
functions <code>fwrite()</code> (file write)
or <code>fputs()</code> (file put string);
<code>fputs()</code> is an alias to <code>fwrite()</code> .
You call fwrite() in the following way:</p>
<blockquote><code>
fwrite($fp, $outputstring);<br>
</code></blockquote>
    <p>
This function call tells PHP to write the string stored in
<code>$outputstring</code> to the file pointed to by <code>$fp.</code>
</p>
    <p>
One new alternative to <code>fwrite(</code>) is the
<code>file_put_contents()</code> function.
It has the following prototype:</p>
<blockquote><code>
int file_put_contents ( string filename,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
string data<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[, int flags<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[, resource context ]])<br>
</code></blockquote>
    <p>
This function writes the string contained in data to the file named in filename
without any need for an <code>fopen(</code>) (or <code>fclose()</code>) function call.
This function is new in PHP5, and is a matched pair for
<code>file_get_contents()</code> , which we discuss shortly.
You most commonly use the flags and context optional parameters when writing
to remote files using, for example, HTTP or FTP.
  </p>
  </li>
 <li>
    <p>
Parameters for fwrite()</p>
    <p>
The function <code>fwrite()</code> actually takes three
parameters, but the third one is optional.
The prototype for <code>fwrite()</code> is</p>
<code>
&nbsp;&nbsp;int fwrite ( resource handle , string string [, int length ])<br>
</code>
    <p>
The third parameter, "length", is the maximum number of bytes to write.
If this parameter is supplied, <code>fwrite()</code> will write "string" to the
file pointed to by "handle" until it reaches the end of "string" or has written
"length" bytes, whichever comes first.</p>
    <p>
You can obtain the string length by using PHP's built-in
<code>strlen()</code> function, as follows:</p>
<code>
&nbsp;&nbsp;fwrite($fp, $outputstring, strlen($outputstring));<br>
</code>
    <p>
You may want to use this third parameter when writing in binary mode
because it helps avoid some cross-platform compatibility issues.</p>
  </li>
  <li>
    <p>
File Formats</p>
    <p>
When you are creating a data file like the one in the example, the
format in which you store the data is completely up to you.
(However, if you are planning to use the data file in another application,
you may have to follow that application's rules.)</p>
    <p>
We need to construct a string that represents one record in the data file.
You  can do this as follows:</p>
<code>
$outputstring = $date . "\t" . $tireqty . " tires \t"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. $oilqty . " oil\t " . $sparkqty<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. " spark plugs\t\$" . $totalamount<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. "\t" . $address . "\n";<br>
</code>
    <p>
In this simple example, you store each order record on a separate line in the file.
Writing one record per line gives you a simple record separator in the newline
character. Because newlines are invisible, you can represent them with the control
sequence "\n".</p>
    <p>
When writing to a file, we write the data fields in the same order every
time and separate fields with a tab character. Again, because a tab character is
invisible, it is represented by the control sequence "\t".
You may choose any sensible delimiter that is easy to read back.</p>
    <p>
The separator or delimiter character should be something that will
certainly not occur in the input, or you should process the input to remove or escape
out any instances of the delimiter. For now, we will assume
that nobody will place a tab into the order form.
It is difficult, but not impossible, for a
user to put a tab or newline into a single-line HTML input
field.</p>
    <p>
Using a special field separator allows you to split the data back into
separate variables more easily when you read the data back.
Here, we treat each order as a single string.</p>
    <p>
After a few orders are processed, the contents of the file look
something like the example shown below:
  </p>
<code><small>
  20:30, 31st March&nbsp; 4 tires&nbsp;&nbsp; 1 oil&nbsp; 6 spark plugs&nbsp; $434.00&nbsp; 22 Short St, Smalltown<br>
20:42, 31st March&nbsp; 1 tires&nbsp;&nbsp; 0 oil&nbsp; 0 spark plugs&nbsp; $100.00&nbsp; 33 Main Rd, Newtown<br>
20:43, 31st March&nbsp; 0 tires&nbsp;&nbsp; 1 oil&nbsp; 4 spark plugs&nbsp; $26.00&nbsp; 127 Acacia St,&nbsp;Springfield <br>
</small></code>
</li><li>
    <p>
Closing a File</p>
    <p>
After you have finished using a file, you need to close it.
You should do this by using the <code>fclose()</code> function as
follows:</p>
<blockquote><code>
fclose($fp);<br>
</code></blockquote>
    <p>
This function returns true if the file was successfully closed or
false if it was not.
This process is much less likely to go wrong than opening a file in the
first place, so in this case we have chosen not to test it.</p>
    <p>
Here is the complete listing for the final version of the PHP script
<a href="../examples/processorder_php.html">processorder.php</a>
</p>
</li>
</ul>
</div>
</body>
</html>
