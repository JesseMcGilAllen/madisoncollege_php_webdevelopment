<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<title>Regular Expressions</title>
<link href="basic.css" rel="stylesheet" type="text/css">
<script type="text/javascript" language="JavaScript">

<!--

function putSemester() {

 var today=new Date();

 var thisMonth=today.getMonth()+1;

 var thisYear=today.getFullYear();

 if(thisMonth <=6) {

 return "Spring, " + thisYear;

 }

 else {

 return "Fall, " + thisYear;

 }

}//-->

 </script>
 
 
 <style type="text/css">

<!--

 .bgStripes {

 background-image:url(images/Xstripes.gif);

 background-attachment: fixed;

 }

 

 body {

 background-color:white;

 }

 

 strong {

 font-family: Arial, Helvetica, sans-serif;

 }

 

 .table1 {

 font-family:Arial, Helvetica, sans-serif;

 font-size: small;

 }

 

 .table2 {

 font-family:Arial, Helvetica, sans-serif;

 font-size: small;

 text-align:center;

 }

 

 td.cen {

 text-align:center;

 }

 

 .small_title {

 font-family: Arial, Helvetica, sans-serif;

 font-size:x-small;

 font-weight:bold;

 }

 

 .med_title {

 font-family: Arial, Helvetica, sans-serif;

 font-size:medium;

 font-weight:bold;

 text-align:center;

 color:darkblue;

 }



 -->

 </style>
</head>
<body style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<table class="bgStripes" border="0" width="100%">
<tbody>
<tr name="firstRow">
<td valign="top" width="80">
<p class="small_title">
<script type="text/javascript">

 <!--

 document.write(putSemester());

 -->

</script>
</p>
<br>
</td>
<td>
<p class="med_title">PHP Web Development with MySQL<br>
</p>
</td>
<td align="right" valign="top" width="80">
<p class="small_title">3 Credits</p>
</td>
</tr>
<tr>
<td colspan="3" height="10">
<p class="small_title" align="center">152-166</p>
</td>
</tr>
</tbody>
</table>


<!--The heading for the slides --> <br>


<table class="headTable1" border="0">
<tbody>
<tr>
<td width="100">
<a href="strings.html"><img alt="" src="images/btn_lArrow.gif" border="0"></a><a href="index.html"><img alt="" src="images/btn_upArrow.gif" border="0"></a><a href="index.html"><img alt="" src="images/btn_rArrow.gif" border="0"></a>
</td>
<td>
<p>Regular Expressions<br>
</p>
</td>
</tr>
</tbody>
</table>
<br>
<div class="disp1">
<ul class="slidesUl1">
<li>
<p>
Introducing Regular Expressions</p>
<p>
PHP supports two styles of regular expression syntax: POSIX and Perl.
The POSIX style of regular expression is compiled into PHP by default,
but you can use the Perl style by compiling in the Perl-compatible
regular expression (PCRE) library. We cover the simpler POSIX style here,
but if you are already a Perl programmer or want to learn more
about PCRE, read the online manual at <code>http://php.net</code> .</p>
<p><strong>
Note:</strong>
POSIX regular expressions are easier to learn, but they are not binary safe.</p>
<p>
So far, all the pattern matching we have done has used the string functions.
We have been limited to exact matches or to exact substring matches.
If you want to do more complex pattern matching, you should use regular expressions.
Regular expressions are difficult to grasp at first but can be extremely useful.</p>
</li>
<li>
<p>
The Basics</p>
<p>
A regular expression is a way of describing a pattern in a piece of text.
The exact (or literal) matches we have seen so far are a form of regular expression.
For example, earlier we searched for regular expression terms such as "shop"
and "delivery".</p>
<p>
Matching regular expressions in PHP is more like a <code>strstr()</code>
match than an equal comparison because you are matching a string
somewhere within another string.
(It can be anywhere within that string unless you specify otherwise.)
For example, the string "shop" matches the regular expression "shop".
It also matches the regular expressions "h", "ho", and so on.</p>
<p>
You can use special characters to indicate a meta-meaning in addition
to matching characters exactly.
For example, with special characters you can indicate that a pattern
must occur at the start or end of a string, that part of a pattern can
be repeated, or that characters in a pattern must be of a particular type.
You can also match on literal occurrences of special characters.
We look at each of these variations next.</p>
</li>
<li>
<p>
Sets of Characters and Classes</p>
<p>
Using sets of characters immediately gives regular expressions more power
than exact matching of expressions.
Sets of characters can be used to match any character of a particular
type. This is similar to using wildcard matching.</p>
<p>
First, we can use the "." character as a wildcard for any other single
character except a newline (<code>\n</code>).
For example, the regular expression:
<blockquote><code>
.at<br>
</code></blockquote>
<p>
matches the strings "cat", "sat",  and "mat", among others.
This kind of wildcard matching is often used for filename matching in
operating systems.</p>
<p>
With regular expressions, however, you can be more specific about the type of
character you would like to match and can actually specify a set that a
character must belong to.
In the preceding example, the regular expression matches "cat" and
"mat" but also matches "#at". If you want to limit this to a character
between "a" and "z", you can specify it as follows:</p>
<blockquote><code>
[a-z]at<br>
</code></blockquote>
<p>
Anything enclosed in the square brackets (<code>[]</code>) is a character
class - a set of characters to which a matched character must belong.
Note that the expression in the square brackets matches only a single
character.</p>
<p>
We can list a set; for example:</p>
<blockquote><code>
[aeiou]<br>
</code></blockquote>
<p>
means any vowel.</p>
<p>
We can also describe a range, as we just did using the hyphen as a special
character, or a set of ranges, as follows:</p>
<blockquote><code>
[a-zA-Z]<br>
</code></blockquote>
<p>
This set of ranges stands for any alphabetic character in upper- or
lowercase.</p>
<p>
You can also use sets to specify that a character cannot be a member of a set.
For example:</p>
<blockquote><code>
[^a-z]<br>
</code></blockquote>
<p>
matches any character that is not between "a" and "z".
The caret symbol (^) means not when it is placed inside the square brackets.
It has another meaning when used outside square brackets,
which we look at shortly.</p>
<p>
In addition to listing out sets and ranges, you can use a number of
predefined character classes in a regular expression.
These classes are shown in the table below:</p>
<p>
Table - Character Classes for Use in POSIX-Style Regular Expressions
</p>
<blockquote><code><small>
<strong><u>
Class
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Matches
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u></strong><br>
[[:alnum:]]&nbsp;
Alphanumeric characters<br>
[[:alpha:]]&nbsp;
Alphabetic characters<br>
[[:lower:]]&nbsp;
Lowercase letters<br>
[[:upper:]]&nbsp;
Uppercase letters<br>
[[:digit:]]&nbsp;
Decimal digits<br>
[[:xdigit:]]
Hexadecimal digits<br>
[[:punct:]]&nbsp;
Punctuation<br>
[[:blank:]]&nbsp;
Tabs and spaces<br>
[[:space:]]&nbsp;
Whitespace characters<br>
[[:cntrl:]]&nbsp;
Control characters<br>
[[:print:]]&nbsp;
All printable characters<br>
[[:graph:]]&nbsp;
All printable characters<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
except for space<br>
</small></code></blockquote>
</li>
<li>
<p>
Repetition</p>
<p>
Often, you may want to specify that there might be multiple occurrences
of a particular string or class of character.
You can represent this using two special characters in your regular expression.
The "*" symbol means that the pattern can be repeated zero or more times,
and the "+" symbol means that the pattern can be repeated one or more times.
The symbol should appear directly after the part of the expression that it
applies to. For example:</p>
<blockquote><code>
[[:alnum:]]+<br>
</code></blockquote>
<p>
means "at least one alphanumeric character."</p>
</li>
<li>
<p>
Subexpressions</p>
<p>
Being able to split an expression into subexpressions is often useful
so that you can, for example, represent "at least one of these strings
followed by exactly one of those".
You can split expressions using parentheses, exactly the same way as you
would in an arithmetic expression. For example:</p>
<blockquote><code>
(very )*large<br>
</code></blockquote>
<p>
matches "<code>large</code>", "<code>very large</code>",
"<code>very very large</code>", and so on.</p>
</li>
<li>
<p>
Counted Subexpressions</p>
<p>
You can specify how many times something can be repeated by using a
numerical expression in curly braces ({}).
You can show an exact number of repetitions
({3} means exactly three repetitions),
a range of repetitions ({2, 4} means from
two to four repetitions), or an open-ended range of repetitions ({2,}
means at least two repetitions). For example:</p>
<blockquote><code>
(very ){1,3}<br>
</code></blockquote>
<p>
matches "<code>very </code>", "<code>very very </code>" and
"<code>very very very </code>".</p>
</li>
<li>
<p>
Anchoring to the Beginning or End of a String</p>
<p>
The pattern <code>[a-z]</code> will match any string containing a
lowercase alphabetic character. It does not matter whether the string
is one character long or contains a single matching
character in a longer string.</p>
<p>
You also can specify whether a particular subexpression should appear
at the start, the end, or both.
This capability is useful when you want to make sure that
only your search term and nothing else appears in the
string.</p>
<p>
The caret symbol (^) is used at the start of a regular expression to
show that it must appear at the beginning of a searched string,
and ($) is used at the end of a regular expression
to show that it must appear at the end.</p>
<p>
For example, the following matches "bob" at the start of a string:</p>
<blockquote><code>
^bob<br>
</code></blockquote>
<p>
This pattern matches "com" at the end of a string:</p>
<blockquote><code>
com$<br>
</code></blockquote>
<p>
Finally, this pattern matches a string containing only a single
character from "a" to "z":</p>
<blockquote><code>
^[a-z]$<br>
</code></blockquote>
</li>
<li>
<p>
Branching</p>
<p>
You can represent a choice in a regular expression with a vertical pipe.
For example, if you want to match "com", "edu", or "net",
you can use the following expression:</p>
<blockquote><code>
com|edu|net<br>
</code></blockquote>
</li>
<li>
<p>
Matching Literal Special Characters</p>
<p>
If you want to match one of the special characters mentioned in the
preceding sections, such as ".", "{", or "$", you must put a backslash
(\) in front of it. If you want to represent a backslash,
you must replace it with two backslashes (\\).</p>
<p>
<b>Note:</b> It is usually best to put regular expression patterns in
single-quoted strings in PHP. Using regular expressions in double-quoted strings
causes complications.</p>
<p>
PHP also uses the backslash to escape special characters - such as
a backslash. If you want to match a backslash in your pattern,
you need to use two to indicate that it is a literal
backslash, not an escape code.</p>
<p>
Similarly, if you want a literal backslash in a double-quoted PHP
string, you need to use two for the same reason.
The somewhat confusing, cumulative result of these rules is
that a PHP string that represents a regular expression containing a
literal backslash needs four backslashes.
The PHP interpreter will parse the four backslashes as two.
Then the regular expression interpreter will parse the two as one.</p>
<p>
The dollar sign is also a special character in double-quoted PHP
strings and regular expressions.
To get a literal "$" matched in a pattern, you would need "\\\$".
Because this string is in double quotation marks,
PHP will parse it as "\$", which the regular expression
interpreter can then match against a dollar sign!</p>
</li>
<li>
<p>
Reviewing the Special Characters</p>
<p>
A summary of all the special characters is shown in the two tables that follow.</p>
<p>
Table - Summary of Special Characters Used in POSIX Regular Expressions
Outside Square Brackets</p>
<blockquote><code><small>
<strong><u>
Character&nbsp;&nbsp;&nbsp;
Meaning
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u></strong><br>
&nbsp;
\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Escape character<br>
&nbsp;
^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Match at start of string<br>
&nbsp;
$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Match at end of string<br>
&nbsp;
.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Match any character except newline (\n)<br>
&nbsp;
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Start of alternative branch (read as OR)<br>
&nbsp;
(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Start subpattern<br>
&nbsp;
)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
End subpattern<br>
&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Repeat zero or more times<br>
&nbsp;
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Repeat one or more times<br>
&nbsp;
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Start min/max quantifier<br>
&nbsp;
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
End min/max quantifier<br>
&nbsp;
?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Mark a subpattern as optional<br>
</small></code></blockquote>
<p>
Table - Summary of Special Characters Used in POSIX Regular Expressions
Inside Square Brackets</p>
<blockquote><code><small>
<strong><u>
Character&nbsp;&nbsp;&nbsp;
Meaning
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u></strong><br>
&nbsp;
\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Escape character<br>
&nbsp;
^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NOT, only if used in initial position<br>
&nbsp;
-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Used to specify character ranges<br>
</small></code></blockquote>
</li>
<li>
<p>
Putting It All Together for the Smart Form</p>
<p>
There are at least two possible uses of regular expressions in the
Smart Form application.
The first use is to detect particular terms in the customer feedback.
You can be slightly smarter about this using regular expressions.
Using a string function, you would have to
perform three different searches if you wanted to match on
"shop", "customer service", or "retail".
With a regular expression, you can match all three:</p>
<blockquote><code>
shop|customer service|retail<br>
</code></blockquote>
<p>
The second use is to validate customer email addresses in the
application by encoding the standardized format of an email address
in a regular expression. The format includes
some alphanumeric or punctuation characters, followed by an "@" symbol,
followed by a string of alphanumeric and hyphen characters,
followed by a dot, followed by more alphanumeric and hyphen characters
and possibly more dots, up until the end of the string,
which encodes as follows:</p>
<blockquote><code>
^[a-zA-Z0-9_\-.]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-.]+$<br>
</code></blockquote>
<p>
The subexpression<code> ^[a-zA-Z0-9_\-.]+ </code>means
"start the string with at least one letter,
number, underscore, hyphen, or dot, or some combination of those".
Note that when a dot is used at the beginning or end of a character class,
it loses its
special wildcard meaning and becomes just a literal dot.</p>
<p>
The @ symbol matches a literal "@".</p>
<p>
The subexpression<code> [a-zA-Z0-9\-]+ </code>matches the
first part of the hostname including alphanumeric characters and hyphens.
Note that you slash out the hyphen because it is a
special character inside square brackets.</p>
<p>
The "<code>\.</code>" combination matches a literal period or dot (.).
We are using a dot outside character classes,
so we need to escape it to match only a literal dot.</p>
<p>
The subexpression<code> [a-zA-Z0-9\-\.]+$ </code>matches
the rest of a domain name, including letters, numbers, hyphens,
and more dots if required, up until the end of the string.</p>
<p>
A bit of analysis shows that you can produce invalid email addresses
that will still match this regular expression.
It is almost impossible to catch them all, but this will
improve the situation a little. You can refine this expression in many
ways. You can, for example, list valid top-level domains (TLDs).
Be careful when making things more restrictive, though,
because a validation function that rejects 1% of valid data is far more
annoying than one that allows through 10% of invalid data.</p>
<p>
Now that you have read about regular expressions, you are ready
to look at the PHP functions that use
them.</p>
</li>
<li>
<p>
Finding Substrings with Regular Expressions</p>
<p>
Finding substrings is the main application of the regular expressions
you just developed.
The two functions available in PHP for matching POSIX-style regular
expressions are <code>ereg()</code> and <code>eregi()</code> .
The <code>ereg()</code> function has the following prototype:</p>
<blockquote><code><small>
int ereg(string pattern, string search, array [matches]);<br>
</small></code></blockquote>
<p>
This function searches the "search" string, looking for matches to
the regular expression in "pattern".
If matches are found for subexpressions of "pattern",
they will be stored in the array "matches",
one subexpression per array element.</p>
<p>
The <code>eregi()</code> function is identical except that it is not
case sensitive.</p>
<p>
You can adapt the Smart Form example to use regular expressions as
follows:</p>
<blockquote><code><small>
if (!eregi('^[a-zA-Z0-9_\-\.]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-\.]+$',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$email))<br>
{<br>
&nbsp;&nbsp;echo 'That is not a valid email address. '<br>
&nbsp;&nbsp;&nbsp;&nbsp;
. 'Please return to the previous page and try again.';<br>
&nbsp;&nbsp;exit;<br>
}<br>
$toaddress = 'feedback@example.com'; // the default value<br>
if (eregi('shop|customer service|retail', $feedback))<br>
&nbsp;&nbsp;$toaddress = 'retail@example.com';<br>
else if (eregi('deliver|fulfill', $feedback))<br>
&nbsp;&nbsp;$toaddress = 'fulfillment@example.com';<br>
else if (eregi('bill|account', $feedback))<br>
&nbsp;&nbsp;$toaddress = 'accounts@example.com';<br><br>
if (eregi('bigcustomer\.com', $email))<br>
&nbsp;&nbsp;$toaddress = 'bob@example.com';<br>
</small></code></blockquote>
</li>
<li>
<p>
Replacing Substrings with Regular Expressions</p>
<p>
You can also use regular expressions to find and replace substrings in
the same way as you used <code>str_replace()</code> .
The two functions available for this task are <code>ereg_replace()</code>
and <code>eregi_replace()</code> . The function
<code>ereg_replace()</code> has the following prototype:</p>
<blockquote><code><small>
string ereg_replace(string pattern, string replacement, string search);<br>
</small></code></blockquote>
<p>
This function searches for the regular expression "pattern" in the
"search" string and replaces it with the string "replacement".</p>
<p>
The function <code>eregi_replace()</code> is identical but,
again, is not case sensitive.</p>
</li>
<li>
<p>
Splitting Strings with Regular Expressions</p>
<p>
Another useful regular expression function is <code>split()</code> ,
which has the following prototype:</p>
<blockquote><code><small>
array split(string pattern, string search [, int max]);<br>
</small></code></blockquote>
<p>
This function splits the string "search" into substrings on the regular
expression "pattern" and returns the substrings in an array.
The "max" integer limits the number of items that can go into the array.</p>
<p>
This function can be useful for splitting up email addresses, domain
names, or dates. For example:</p>
<blockquote><code>
$address = 'username@example.com';<br>
$arr = split ('\.|@', $address);<br>
while (list($key, $value) = each ($arr))<br>
&nbsp;&nbsp;echo '&lt;br /&gt;'.$value;<br>
</code></blockquote>
<p>
This example splits the email address into its three components and prints
each on a separate line.</p>
</li>
<li>
<p>
Comparing String Functions and Regular Expression Functions</p>
<p>
In general, the regular expression functions run less efficiently than
the string functions with similar functionality.
If your task is simple enough to use a string expression, do so.
This may not be true for tasks that can be performed with a single
regular expression but multiple string functions.</p>
<p>
PHP has many string functions.
We covered some of the more useful ones in this unit, but if
you have a particular need
(such as translating characters into Cyrillic),
check the PHP manual online to see whether PHP has a function
that fits your needs.</p>
<p>
The amount of material available on regular expressions is enormous.
You can start with the man page for "regexp" if you are using Unix,
and you can also find some terrific articles at
<code>devshed.com</code> and <code>phpbuilder.com</code> .</p>
</li>
</ul>
</div>
</body>
</html>
