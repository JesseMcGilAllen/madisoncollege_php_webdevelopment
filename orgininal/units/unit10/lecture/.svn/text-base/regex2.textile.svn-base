h2. Repeating Patterns and Regular Expressions in Files and Forms

<hr />

h3. Metacharacters to Repeat Pattern Matches

* In the previous examples, the metacharacter matched on a single character. What if you want to match on more than one character?
* For example, let's say you are looking for all lines containing names and the first letter must be in uppercase, which can be represented as @[A-Z]@, but the following letters are lowercase and the number of letters varies in each name. @[a-z]@ matches on a single lowercase letter.
* How can you match on one or more lowercase letters? Zero or more lowercase letters? To do this you can use what are called "quantifiers".
* To match on one or more lowercase letters, the regular expression can be written: @/[a-z]+/@ where the "@+@" sign means "one or more of the previous characters", in this case, one or more lowercase letters.
* PHP provides a number of quantifiers as shown in the table below.
* Table: The Greedy Metacharacters

table{text-align:left; margin-left: 4em;}.
|{background:#ccc}.*Metacharacter*|{background:#ccc}.*What It Matches*|
|@x?@             |Matches 0 or 1 occurrences of the letter x.                                                   |
|@(xyz)?@         |Matches 0 or 1 pattern of xyz.                                                                |
|@x*@             |Matches 0 or more occurrences of the letter x.                                                |
|@(xyz)*@         |Matches 0 or more patterns of xyz.                                                            |
|@x+@             |Matches 1 or more occurrences of the letter x.                                                |
|@(xyz)+@         |Matches one or more patterns of xyz.                                                          |
|@x{m}@           |Matches exactly m occurrences of the letter x.                                                |
|@x{m,n}@         |Matches at least m occurrences of the letter x and no more than n occurrences of the letter x.|
|@x{m,}@          |Matches m or more occurrences of the letter x.                                                |


h3.  The Greed Factor

* Normally quantifiers are greedy; that is, they match on the largest possible set of characters starting at the left side of the string and searching to the right, looking for the last possible character that would satisfy the condition. For example, given the string:
<br /><pre>
var string="ab123456783445554437AB"
</pre>
* and the regular expression:
<br /><pre>
/ab[0-9]*/
</pre>
* If the *@preg_replace()@* function were to substitute what is matched with an "@X@"
<br /><pre>
$new_string = preg_replace('/ab[0-9]*/','X','ab12345678445554437AB');
</pre>
* The resulting string would be:
<br /><pre>
"XAB"
</pre>
* The asterisk is a greedy metacharacter. It matches zero or more of the preceding characters. In other words, it attaches itself to the character preceding it.
* In the preceding example, the asterisk attaches itself to the character class @[0-9]@. The matching starts on the left, searching for "ab" followed by zero or more numbers in the range between 0 and 9.
* It is called greedy because the matching continues until the last number is found, in this example the number 7. The pattern "ab" and all of the numbers in the range between 0 and 9 are replaced with a single "X".
* Greediness can be turned off so that instead of matching on the maximum number of characters, the match is made on the minimal number of characters found.
* This is done by appending a question mark after the greedy metacharacter.
* Filename: *quantifiers.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/e\s?[A-Z]/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The first argument to the *@preg_match()@* function is a regular expression containing a quantifier. The function will return TRUE if the pattern is matched in *@$text@* that is, a letter "e" followed by either a space or no space at all, and an uppercase letter.
* The question mark means "zero or one of the preceding character". Note that the letter "e" in DeLoach is not followed by a space (zero or more spaces).

h3. The @*@ Metacharacter and Greed

* The @*@ metacharacter is often misunderstood as being a wildcard to match on everything, but it only matches the character that precedes it.
* In the regular expression @/ab*c/@ the asterisk is attached to the "b", meaning that zero or more occurrences of the letter "b" will be matched. The strings "abc", "abbbbbbbc", and "ac" would all be matched.
* Filename: *quantifiers2.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/B[a-z]*/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
The first argument to the *@preg_match()@* function is a regular expression containing a greedy metacharacter. The function will return TRUE if the pattern is matched in *@$text@* that is, a pattern that begins with an uppercase "B", followed by zero or more lowercase letters.
The only character required to make a match is the first "B". The starred character class represents zero or more letters ranging from "a" to "z", which means there might not be any at all, as shown with "BB Kingson".
Filename: quantifiers3.php
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/^[A-Z][a-z]*\s[A-Z][a-z]*\s/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The first argument to the *@preg_match()@* function is a regular expression containing a greedy metacharacter. The function will return TRUE if the pattern is matched in *@$text@* that is, a pattern that begins with an uppercase letter, followed by zero or more lowercase letters, a space, another uppercase letter, followed by zero or more lowercase letters (only lowercase), and a space.
* Because the last name DeLoach contains an uppercase letter "D", followed by both upper-and lowercase letters, this line is not a match.
* The first name in "BB Kingson" is not a match because the first letter is not followed by a lowercase letter or a space.
* Filename: *quantifiers4.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/^[A-Z][a-z]*\s[A-Z][a-zA-Z]*\s/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The first argument to the *@preg_match()@* function is a regular expression containing a greedy metacharacter. The function will return TRUE if the pattern is matched in *@$text@* that is, a pattern that begins with an uppercase letter, followed by zero or more lowercase letters, a space, another uppercase letter, followed by zero or more upper- and lowercase letters.
* In the previous example, DeLoach did not match because the last name contained a mix of upper- and lowercase letters. That problem was addressed in this example, by including @[a-zA-Z]@ in the expression, McDougal or MacDonald would also match, but what about O'Reilley?

h3. The @+@ Metacharacter and Greed

* The "@+@" metacharacter attaches itself to the preceding character and matches on one or more of that character.
* Filename: quantifiers5.php
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/B[a-z]+/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The first argument to the *@preg_match()@* function is a regular expression containing a greedy metacharacter, the "@+@" sign. The function will return TRUE if the pattern is matched in *@$text@* that is, a pattern consisting of an uppercase "B", followed by one or more lowercase letters @[a-z]+@ .

h3. Matching for Repeating Characters

* To match for a character that is repeated a fixed number of times, the character is followed by a set of curly braces containing a number to represent how many times the pattern should be repeated.
* A single number within the curly braces (e.g., {5}), represents an exact amount of occurrences; two numbers separated by a comma (e.g., {3,10}), represents an inclusive range; and a number followed by a comma (e.g., {4,}), represents a minimum number of occurrences and any amount after that.
* Table: Repeating Characters

table{text-align:left; margin-left: 4em;}.
|{background:#ccc}.*Metacharacter*|{background:#ccc}.*What It Does*|
|a{10}          |Matches exactly 10 occurrences of the letter a.     |
|a{3,5}         |Matches between 3 and 5 occurrences of the letter a.|
|a{6,}          |Matches 6 or more occurrences of the letter a.      |

* Filename: *quantifiers6.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/\s\d{3}$/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The regular expression contains the curly brace {} metacharacters, representing the number of times the preceeding expression will be repeated.
* The expression matches for a space, followed by exactly 3 repeating digits, anchored at the end of the line *@($)@*.

h3. Metacharacters That Turn Off Greediness

* By placing a question mark after a greedy quantifier, the greed is turned off and the search ends after the first match, rather than the last one.
* Filename: *noGreed.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    $newtext = preg_replace('/B.* /','John ', $text);
 8:    echo $newtext,'<br />';
 9:    $text = fgets($fh);
10:  }
11:  echo '<hr width="75%">';
12:  rewind($fh);
13:  $text = fgets($fh);
14:  while (!feof($fh)) {
15:    $newtext = preg_replace('/B.*? /','John ', $text);
16:    echo $newtext,'<br />';
17:    $text = fgets($fh);
18:  }
19:?>
</pre>
* The first regular expression contains @"B.*"@. The @".*"@ means zero or more of any character. When a "B" is matched, it and all characters after it until the last space will be consumed and replaced with "John".
* The Bear in the line Mama Bear will be replaced with John; Blenheim in the line Steve Blenheim is replaced with "John"; and Betty Boop is also replaced with "John".
* The *@rewind()@* function moves the file pointer back to the beginning of the file *@($fh)@*, so that we can loop through it again.
* By placing a "@?@" after the "@.*@" in the second regular expression, the greed factor of the asterisk is turned off; that is, find a "B", followed by zero or more characters up until the first space and replace it with "John".

h3. Metacharacters for Alternation

* Alternation allows the regular expression to contain alternative patterns to be matched; for example, the regular expression /John|Karen|Steve/ will match a line containing John or Karen or Steve.
* If Karen, John, or Steve are all on different lines, all lines are matched. Each of the alternative expressions is separated by a vertical bar (pipe symbol) and the expressions can consist of any number of characters, unlike the character class that only matches for one character.
* that is, /a|b|c/ is the same as @[abc]@ , whereas /ab|de/ cannot be represented as @[abde]@ . The pattern /ab|de/ is either "ab" or "de", whereas the class @[abcd]@ represents only one character in the set: "a", "b", "c", or "d".
* Filename: *alternates.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/Steve|Betty|Jon/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The pipe symbol @(|)@ is used in the regular expression to match on a set of alternative string patterns. If any of the strings, "Steve", "Betty", or "Jon", are found, the match is successful.
* The preg_match function will return true if the pattern contains either Steve, Betty, or Jon.

h3. Grouping or Clustering

* If the regular expression pattern is enclosed in parentheses, a subpattern is created. Then, for example, instead of the greedy metacharacters matching on zero, one, or more of the previous single character, they can match on the previous subpattern.
* Alternation can also be controlled if the patterns are enclosed in parentheses. This process of grouping characters together is also called clustering.
* Filename: *grouping.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/(Steve|Alexander) Blenheim/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The regular expression contains the alternation character; the alternative patterns are "Steve" and "Alexander". By enclosing this pattern in parentheses, it is treated as a grouped unit so that the regular expression matches either Steve Blenheim or Alexander Blenheim.
* Filename: *grouping2.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/(ma)+/', $text)) {
 8:      echo $text,'<br />';
 9:    }
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* If one or more occurrences of the pattern "ma" are found, the *@preg_match()@* function will return TRUE. The "+" metacharacter is applied to the group of characters within the parentheses; that is, "ma".

h3. Remembering or Capturing

* If the regular expression pattern is enclosed in parentheses, a subpattern is created. The subpattern is found in the third argument to *@preg_match()@* as an array of subpatterns.
* With *@preg_replace()@*, parenthesized patterns can be backreferenced by using a backslash and the number of the pattern; for example, the first parenthesized pattern is referenced as "\1", the second as "\2", the third as "\3", up to "\"9.
* If enclosed in double quotes, the backreferences are referenced as "\\1", "\\2", "\\3", and so on. Newer versions of PHP use "*@$1@*", "*@$2@*", "*@$3@*", and so on, rather than backslashes without limit on the number of subpatterns captured.
* Filename: *capture2.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    if (preg_match('/(Steve)\s(Blenheim)/', $text, $matches)) {
 8:      echo "$matches[0]<br />";
 9:      echo "$matches[1]<br />";
10:      echo "$matches[2]<br />";
11:    }
12:    $text = fgets($fh);
13:  }
14:?>
</pre>
* The regular expression contains two subpatterns, "Steve" and "Blenheim" both enclosed in parentheses. These patterns are captured and saved in the third argument to *@preg_match()@*, an array called *@$matches@* that contains the whole pattern in @$matches[0]@, the captured pattern "Steve", in @$matches[1]@, and the captured pattern "Blenheim", in @$matches[2]@.
* Filename: *matchVars.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    $new = preg_replace('/(Betty)\s(Boop)/','$2, $1',$text);
 8:    echo $new .'<br />';
 9:
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The *@preg_replace()@* function will search the target string containing the regular expression with two parenthesized subpatterns. The first one, (Betty), will be captured in $1, the second one, (Boop), will be captured in *@$2@*.
* The second argument is the replacement string and contains the captured subpatterns. It causes the subpatterns to be reversed in the replacement string.

h3. Searching, Capturing, and Replacing

* If the search pattern contains parenthesized (captured) strings, those subpatterns can be referenced in the replacement side by either backslashed numbers such as \1, \2, up to \9, or the preferred way since PHP 4.0.4, with *@$1@*, *@$2@*, up to *@$99@*.
* The number refers to the position where the parenthesized pattern is placed in the search pattern (left to right); for example, the first captured string is referenced in the replacement string as *@$1@*, the second as *@$2@*, and so on.
* *@$0@* or \0 refers to the text matched by the entire pattern.
* Filename: *matchVars2.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    $new = preg_replace('/(\w+)\s(\w+)\s(\w+)/','$2, $1 $3',
 8:                        $text);
 9:    echo $new .'<br />';
10:
11:    $text = fgets($fh);
12:  }
13:?>
</pre>
* The *@preg_replace()@* function will search the target string containing the regular expression with three parenthesized subpatterns.
* The first one, *@(\w+)@*, will be captured in *@$1@*, the second one *@(\w+)@* will be captured in *@$2@*, and everything after the last space will be captured in *@$3@*.
* The second argument is the replacement string and contains the captured subpatterns to be printed in the order in which they are placed.
* Filename: *matchVars3.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('data10.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    list($fname, $lname, $number) = preg_split('/\s+/', $text);
 8:    $new_number = preg_replace('/(\d{3})$/e','$1 * 1.1', $number);
 9:    printf('%s, %s %.2f<br />', $lname, $fname, $new_number);
10:
11:    $text = fgets($fh);
12:  }
13:?>
</pre>
* The *@preg_split()@* function splits up the line by one or more spaces. The *@list()@* function creates variables from each of the items returned from the *@split()@* function.
* The *@preg_replace()@* function will search for any number ending in three digits, capture and save those three digits in *@$1@*, and replace the number it saved with that number, *@$1@*, muliplied by 1.1; that is, increase the number by 10 percent.
* The *@printf()@* function formats and prints the name, last name first, and the number as a floating-point number with precision of two decimal places.

h3. Positive Lookahead

* A lookahead is used to help refine a search but is not part of the resultin g pattern. The lookahead peeks ahead of a pattern in the regular expression to see if the text in the lookahead is there.
* The lookahead text is enclosed in parentheses and prepended with "?=". The text in the lookahead is not captured as in the previous examples, but is only used as criteria for the search.
* For example, the regular expression "@/Bob (?= Black|Jones)/@" says search for Bob and look ahead to see if either Black or Jones are next, and if so, there is a match.
* The parentheses will not capture and create *@$1@*, and the values Black and Jones will not be altered in a replacement.
* Filename: *lookahead.php*
<br /><pre>
 1:<?php
 2:  $fh = fopen('moredata.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    $newstring = preg_replace('/mama (monkey|bird)/i',
 8:                              'Papa $1', $text);
 9:    print $newstring .'<br />';
10:    $text = fgets($fh);
11:  }
12:
13:  rewind($fh);
14:  $text = fgets($fh);
15:  # Forward lookahead
16:  print '-------lookahead---------<br />';
17:  while(!feof($fh)) {
18:    $newstring = preg_replace('/mama (?=monkey|bird)/i',
19:                              'Papa ', $text);
20:    print $newstring .'<br />';
21:    $text = fgets($fh);
22:  }
23:?>
</pre>
* The data file this time is "moredata.txt", which is opened for reading.
* The regular expression used in the first while loop does not use a positive lookahead. Instead, it uses capturing.
* The *@preg_replace()@* function searches (case-insensitive) for either "mama monkey" or "mama bird". If either "monkey" or "bird" is found, its value will be captured and placed in *@$1@*.
* The original string will be replaced with either "Papa bird" or "Papa monkey". If *@$1@* were not used in the replacement string, both "mama monkey" and "mama bird" would be replaced with just "Papa ".
* The *@rewind()@* function moves the internal file pointer back to the start of the file.
* The *@preg_replace()@* function in the second while loop searches (case-insensitive) for either "mama monkey" or "mama bird", but uses what is called a lookahead, text preceded by "?=" and enclosed in parentheses.
* Capturing is not performed when using lookahead. Notice that the lookahead text is not included in the replacement string. It simply asserts that either "monkey" or "bird" must follow "mama ", but are not considered part of what will be replaced. "Papa " replaces "mama ". The rest of the string is left intact.

h3. Positive Lookbehind

* Like a positive lookahead, a positive lookbehind is used to help refine a search but is not part of the resulting pattern. It looks to see if the text in the lookbehind precedes the pattern being searched for or replaced.
* The lookbehind text is enclosed in parentheses and prepended with "?<=". The text is not captured as in the previous examples, but is only used as criteria for the search.
* Filename: lookbehind.php
<br /><pre>
 1:<?php
 2:  $fh = fopen('moredata.txt','r');
 3:  if (!$fh)
 4:    exit('File not found.');
 5:  $text = fgets($fh);
 6:  while (!feof($fh)) {
 7:    $newstring = preg_replace('/(?<=ma )[MC][a-z]+/',
 8:                              'Goose', $text);
 9:    print $newstring .'<br />';
10:    $text = fgets($fh);
11:  }
12:?>
</pre>
* The lookbehind is "@(?<=ma )@". The text in the lookbehind is "ma ".
* If that pattern precedes the pattern in the regular expression, "@[MC][a-z]+@", the string will be replaced by "Goose".
* That is, "Norma Cord" and "Mama Monkey" will be replaced with "Norma Goose" and "Mama Goose".

h3. Commenting Regular Expressions and the x Modifier

* You can add whitespace and comments to a regular expression if you want to clarify how the regular expression is broken down and what each symbol means.
* This is very helpful in unraveling a long regular expression you might have inherited from another person or program and are not sure how it works.
* To do this use the "x" modifier after the closing delimiter.
* Filename: *xmodifier.php*
<br /><pre>
 1:<?php
 2:  # /^([A-Z][a-z]+)\s([A-Z][a-zA-Z]+)\s(\d{3})/
 3:  $regex =
 4:     '/
 5:     ^         # At the beginning of the line
 6:     (         # start a new subpattern $1
 7:     [A-Z]     # Find an uppercase letter
 8:     [A-Za-z]  # find an upper or lowercase letter
 9:     *         # match it zero or more times
10:     )         # close first subpattern
11:     \s        # find a whitespace character
12:     (         # start another subpattern $2
13:     [A-Z]     # match an uppercase letter
14:     [a-zA-Z]  # match an upper or lowercase letter
15:     +         # match for one or more of them
16:     )         # close the subpattern
17:     \s        # match a whitespace character
18:     (         # start subpattern $3
19:     \d        # match a digit
20:     {3}       # match it three times
21:     )         # close the subpattern
22:     $         # end of line
23:     /x';
24:
25:  $fh = fopen('data10.txt','r');
26:  if (!$fh)
27:    exit('File not found.');
28:  $text = fgets($fh);
29:  while (!feof($fh)) {
30:    $new_text = preg_replace($regex,'$2, $1 $3', $text);
31:    echo $new_text .'<br />';
32:    $text = fgets($fh);
33:  }
34:?>
</pre>
* Line 2 contains the regular expression (in a comment) that will be broken down and commented.
* The variable *@$regex@* is assigned a commented regular expression where each regular expression metacharacter is described. By breaking down the expression in this way, you can decipher what it is trying to do.
* The "x" modifier at the end of the expression allows the regular expression to contain whitespace and comments without affecting the parsing of the regular expression at all.

h3. Searching for Patterns in Text Files

* You might be using text files, rather than a database, to store information. You can perform pattern matching with regular expressions to find specific data from a file using the PHP built-in functions such as *@preg_match()@* , *@preg_replace()@* , and so on.
* In the following example, a form is provided so that the user can select all names and phone numbers within a particular area code found in a text file.
* Filename: *areaCode.html* - The HTML Form
<br /><pre>
 1:<html>
 2: <head>
 3:  <title>Searching for Area Code from a File</title>
 4: </head>
 5: <body bgcolor="silver">
 6:  <font face="verdana" size="+1">
 7:  <form action="areaCode.php" method="POST">
 8:   <p>
 9:   Please enter the area code
10:   <input type="text" name="area_code" size=5>
11:   </p><p>
12:   <input type="submit">
13:   <input type="reset">
14:   </p>
15:  </form>
16:  </font>
17: </body>
18:</html>
</pre>
* Filename: *areaCode.php* - The PHP Script
<br /><pre>
 1:<html>
 2: <head>
 3:  <title>Finding Phones by Area Code</title>
 4: </head>
 5: <body bgcolor="silver">
 6:  <font face="verdana">
 7:  <?php
 8:    $filename = $_SERVER['DOCUMENT_ROOT'] .'/files/datebook.txt';
 9:    $lines = file($filename);
10:    $area_code = trim($_POST['area_code']);
11:    echo '<h2>Names and Phones in '. $area_code .' area code</h2>';
12:
13:    foreach ($lines as $the_line) {
14:      $fields = explode(':',$the_line);
15:      $name = $fields[0];
16:      $phone = $fields[1];
17:      $address = $fields[2];
18:      $birthday = $fields[3];
19:      $salary = $fields[4];
20:
21:      if (preg_match("/^$area_code-/", $phone)) {
22:         echo "$name: $phone<br />";
23:         $count++;
24:       }
25:     }
26:
27:     if ($count == 0) {
28:        echo 'The area code was not found.<br />';
29:     }
30:  ?>
31:  </font>
32: </body>
33:</html>
</pre>
* In this HTML form, the user is asked to enter an area code into the text box.
* The PHP built-in *@file()@* function reads the entire file and assigns it to an array. Each element of the array is a line of the file.
* The foreach loop is used to cycle through the array; that is, each line of the file.
* Each line is split up into fields where the colon designates the field separator.
* The *@preg_match()@* function searches in the *@$phone@* variable for the area code that was requested by the user in the form.
* The regular expression reads: go to the beginning of the *@$phone@* field, find the area code (value of *@$area_code@*), followed by a dash.
* If the requested area code is found, the *@preg_match()@* function returns true and the block starting on line 22 is entered.
* For every successful match, the counter, *@$count@*, is incremented by 1.
* If the value of *@$count@* is 0 after completing the foreach loop, no matches were found.

h3. Form Validation with PHP

* If you are going to use PHP to validate data in a fillout form, you can use regular expressions to create sophisticated patterns for finding e-mail addresses, phone numbers, credit card data, and so on.
* But rather than create the pattern yourself, there are a number of Web sites that can help you, such as: regexlib.com
* The following table provides regular expressions for input data that can be routinely checked. The example that follows the table shows you how to creat e a form and process the validation using a regular expression.
* Table: Regular Expressions Used for Validating Form Input

table{text-align:left; margin-left: 4em;}.
|{background:#ccc}.*|{background:#ccc}.*|
|Social Security number |<pre>/^\d{3}-?\d\d-?\d{4}$/</pre>|
|U.S. phone number      |<pre>/^\(?\d{3}\)?-?\s*\d{3}\s*-?\d{4}$/</pre>|
|Zip code         |<pre>/^\d{5}((-|\s)?\d{4})?$/</pre>|
|E-mail           |<pre>/^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/</pre> |
|Credit card number     |<pre>/^((4\d{3})&#124;(5[1-5]\d{2})&#124;(6011))-?\d{4}-?\d{4}-?\d{4}&#124;3[4,7]\d{13}$/</pre>|
|URL              |<pre>/^((http|https|ftp)://)?([\w-])+(\.)(\w){2,4}([\w/+=%&_.~?-]*)$/</pre>                       |

h3. Checking for a Valid E-Mail Address

* In the following example, we validate an e-mail address. You can use the same format, and apply any of the regular expressions from the table to create similar functions to add to the validation program.
* When validating an e-mail address, you are looking for the typical format found in such addresses. There might be some domain names that are more than four characters, but it is not typical. Also, just because the user types what looks like a valid e-mail address, does not mean that it is; for example, the e-mail address santa@northpole.org uses a valid syntax, but does not check to see if santa is a real user.
* E-mail addresses usually have the following format:
** An @ sign between the username and address (@lequig@aol.com@).
** At least one dot between the address and domain name (@.com, .mil, .edu, .se@).
** At least six characters @(a@b.se)@. (As of this writing, domain names have at least two characters.)
* The following are examples of valid e-mail addresses:
<br /><pre>
username@mailserver.com
username@mailserver.info
username@mailserver.org.se
username.moretext@mailserver.mil
username@mailserver.co.uk
user-name.moretext.sometext.mailserver.se
</pre>
* Breaking down the regular expression for validating an email:
<br /><pre>
/^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/
</pre>
* ^ Go to the beginning of the line.
* @[a-zA-Z]@ The username must begin with a letter.
* @[\w \.\-]+@ The username can consist of one or more word characters, dots, spaces, dashes; for example: Joe.Shome_somebody
* @[a-zA-Z0-9]@ The last character in the user's name must be an alphanumeric character.
* @@@ A literal @@@ symbol is required in the e-mail addresses.
* @([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+@ The mail server's name is like the user's name, a group consisting of a word character, followed by zero or more word characters and a dash, and then a dot. Because the parentheses are followed by a "@+@", the group can be repeated one or more times.
* @[a-zA-Z]{2,4}@ The domain name follows the mail server's name. The domain name consists of between two and four alphabetic characters; for example: @savageman@IMEFDM.USMC.MIL@ or @patricia.person@sweden.sun.com@
* @$@ This the end-of-line anchor, where the pattern ends.
* This example uses a regular expression to check for a valid e-mail address.
* Filename: validEmail.php
<pre>
 1:<html>
 2: <head>
 3:  <title>Validate an Email Address</title>
 4: </head>
 5: <body bgcolor="#ccffcc">
 6:  <font size="+1" color="darkblue">
 7:  <h1>Validating Email</h1>
 8:  <?php
 9:    $errors = array();
10:    if (isset($_POST['submit'])) {
11:      validate_input();
12:      if (count($errors) != 0) {
13:        show_form();
14:      }
15:      else {
16:        echo '<b>OK! Go ahead and Process the form</b><br />';
17:        echo "<em><b>$_POST[email]</em></b> is a valid email
18:              address.<br />";
19:      }
20:    }
21:    else {
22:      show_form();
23:    }
24:
25:    function validate_input() {
26:      global $errors ;
27:
28:      $email = stripslashes(trim($_POST['email']));
29:      // Did the user enter anything?
30:      if ($email == '') {
31:        $errors['email'] = '<b><font color="red">***Email'
32:                          .' address?***</font><b>';
33:      }
34:      else {
35:        $ok = validate_email($email);
36:        if (!$ok) {
37:          $errors['email'] = '<b><font color="red">***Invalid'
38:                            .' email address***</font></b>';
39:        }
40:      }
41:    }
42:
43:    function validate_email($email) {
44:      $regex = '/^[a-zA-Z][\w \.\-]+[a-zA-Z0-9]@([a-zA-Z0-9]'
45:              .'[a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,4}$/';
46:      if (preg_match($regex, $email)) {
47:        return true;
48:      }
49:      else {
50:        return false;
51:      }
52:    }
53:
54:    function show_form() {
55:      global $errors;
56:      $currEmail = $_POST['email'];
57:  ?>
58:  <form method=POST action="<?php echo $_SERVER['PHP_SELF']?>">
59:   <table cellspacing="0" cellpadding="2">
60:    <tr>
61:     <b> Email address:</b>
62:     <td>
63:      <input type="text" size=30
64:             name="email"
65:             value="<?php echo $currEmail;?>">
66:      <br />
67:      <?php echo $errors['email'];?>
68:     </td>
69:    </tr>
70:    <tr>
71:     <td>&nbsp</td>
72:    </tr>
73:    <tr>
74:     <td>
75:      <input type="submit"
76:             name="submit">
77:     </td>
78:    </tr>
79:    <br />
80:   </table>
81:  </form>
82:  <?php
83:    }
84:  ?>
85: </body>
86:</html>
</pre>
* If the form has already been submitted, then the *@validate_input()@* function will be called on line 11.
* If the *@$errors@* array has elements in it, then there are problems in the way the form was submitted. If there are errors in the way the user filled out the form (the user did not enter an e-mail address or what he or she entered was invalid), the *@show_form()@* function will be called to redisplay the form with the appropriate error message.
* If there were no errors in the submitted input (i.e., the user entered a valid e-mail address), then it is time to process the form. At this point the e-mail address is ready to be sent to a file, database, used to send a message to the user, and so on.
* If the form has not been submitted, the *@show_form()@* function will be called, and the form will appear in the browser.
* If the user did not enter anything at all, the @$errors['email']@ array will be assigned a message that will appear in red under the input field in the browser.
* The regular expression is assigned to the variable *@$regex@* on lines 44-45. The HTML form starts on line 58. When the form is submitted this same script will be called to process it, referenced by *@$_SERVER['PHP_SELF']@*.
* If this is the first time the form was submitted, *@$email@* will have no value. If the form has already been submitted and there were errors, the original value the user typed, stored in *@$email@*, will be replaced in the input text field box. PHP will echo its value and HTML will assign it to the text box.

h3. Help on the Web

There are a number of regular expression validators on the Internet that can help you unravel regular expressions.
The regular expression library at @http://regexlib.com@ is an excellent resource for finding and testing regular expressions for e-mail, phone numbers, credit cards, Social Security numbers, and more.


<br />

<hr />

[[Unit Ten => 152-166 Unit Ten Index]]
