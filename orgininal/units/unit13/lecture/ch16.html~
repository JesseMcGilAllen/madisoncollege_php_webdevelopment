Chapter 16. Cookies and Sessions

16.1. What Is Stateless?

The HTTP Web protocol was designed to be stateless to keep transactions between a browser and server brief and cut down on the overhead of keeping connections open. Stateless means that after a transaction takes place between the browser and server, the connection is lost and neither the browser nor server has any recollection of what transpired between one session and the next. Each request to the server is considered a brand new request. This works well for static documents, but not so well when we need to keep track of a Web site user. Imagine, for example, an online banking Web site. If each request were brand new, you would have to retype your username and password every time you clicked any link on that Web site. You would log in to see your balance, log in again to see a specific transaction, then log in again to make a transfer, and so on.

The shopping cart is used as the most obvious reason for saving state. As the Internet grew, people started filling up their virtual carts with groceries, music, books, prescription drugs, and even cars and homes. It became necessary for merchants to remember what their customers purchased, their preferences, registration numbers, IDs, and so on.

Cookies and sessions are used to let programs like PHP remember past requests. Cookies are used to store small amounts of information on the user's browser, whereas sessions can manage much larger amounts of data and store information on the server side. Because cookies and sessions often work together in saving state, this chapter discusses both methods and the advantages and disadvantages of both.

16.2. What Are Cookies?

Before we delve into using cookies with PHP, let's discuss what they are. In 1994 Netscape came up with the concept of a cookie. A cookie is a small packet of information stored on the browser, and it is persistent, meaning it is maintained between browser sessions and might persist even when the user shuts down his or her computer. The cookie idea became very popular and is now supported by all major browsers.

The term cookie comes from an old programming trick for debugging and testing routines in a program. A text file called a magic cookie was created. It contained text that was shared by two routines so that they could communicate with each other. The cookie feature started by Netscape[1] is also just a little piece of textual data that is stored in a file (often called the cookie jar) on the hard drive of the client (browser). It contains information about the viewer that can be retrieved and used at a later time. The HTTP server sends the cookie in a header to the browser when the browser connects for the first time and from then on, the browser returns a copy of the cookie to the server each time it connects. The information is passed back and forth between the server and browser via HTTP headers.

    [1] See www.netscape.com/newsref/std/cookie_spec.html for cookie specification.

Cookies can make a Web page personal and friendly, and store important information about the user's language, reading, or music preferences; how many times he or she has visited your site; track items in a shopping cart, and so on. They can also be annoying, and some question the security of putting unknown data on their hard drive. Users do have a say about whether or not to use them.

Cookies can be turned off and removed from the hard drive. For example, under the Tools menu in Navigator, go to Cookie Manager, and from there you can block all cookies for a site. If you are using Internet Explorer you can delete cookies by going to the Tools menu and then to Internet Options. For Firefox, you can control cookies by selecting Options from the Tools menu.

Unlike Grandma's old-fashioned cookie jar packed full of sugar cookies, Web browser cookies are limited (although today those limits seem to be higher). Browsers usually cannot store more than 300 cookies and servers usually not more than 20. Storage is usually limited in length to only 4 kilobytes (4,000 characters) per cookie, so you cannot store a lot of information. The actual filename that holds the cookie data varies on different platforms. Netscape Navigator (on Windows) stores cookies in a file named cookies.txt in Navigator's system directory; Internet Explorer stores them in the \Window\Cookies directory; and on the Mac, they are found in a file called MagicCookie. Note: When you are setting cookies, they are stored in the browser's memory and not written to the hard drive until you exit the browser.
16.2.1. Cookie Ingredients

Cookies consist of a string of text stored on the user's hard drive as a small text file. They are sent from a server-side program to the browser through the HTTP request and response headers. The cookie's default lifetime is the length of the current session (when the user exits his or her browser), after which it is destroyed. The expiration time for the end of a cookie's life can be set as an attribute of the Cookie header (see the "Expiration Date" section that follows) making it possible to extend the life of the cookie forever.

Cookies are comprised of text in the form of key–value pairs, often nicknamed "crumbs," and up to 20 pairs can be stored in a single cookie string. The browser stores only one cookie per page.

When making cookies, the crumbs consist of name=value pairs, called attributes, terminated with a semicolon. Within the string, semicolons, commas, or whitespace characters are not allowed. The HTTP Set-Cookie header has the following format.
Format

Set-Cookie: name=value; [expires=date};[ path=path];
            [domain=domainname]; [secure];


Example:

Set-Cookie: id="Bob";expires=Monday, 21-Oct-05 12:00:00 GMT;
            domain="bbb.com"; path="/"; secure;


16.2.2. The Attributes of a Cookie

When setting the cookie, it is important to understand its components. A cookie has a name, a value, and another set of optional attributes to determine the expiration date, the domain, path, and whether the cookie must be sent over a secure communications channel (HTTPS). All of these attributes are assigned as strings.
Name

The actual cookie text consists of the name of the cookie and the value stored there. It can be a session ID, a username, or whatever you like.
Format

nameofcookie=value;


Examples:

id=456;
email=joe@abc.com;
name=Bob;


The name of the cookie is on the left side of the = sign and the cookie text that gets stored is on the right side. The value assigned is a string. To add multiple values to the string, unique characters are used to separate the values, such as Bill*Sanders*345.
Expiration Date

The cookie normally expires when the current browser session ends, which gives it little value, but you can specify an expiration date that will let it persist, by using the following format.
Format

;expires=Weekday, DD-MON-YY HH:MM::SS GMT


Example:

;expires=Friday, 15-Mar-07 12:00:00 GMT


The day of the week is specified by Weekday, the day of the month by DD, the first three letters of the month by MON, and the last two numbers of the year by YY. The hour, minutes, and seconds are specified in HH:MM:SS and the GMT time zone is always used. Some cookies last for days, but it is possible for them to even last for years. It is up to the designer to decide how long a cookie should live. Setting the expiration date also limits the amount of possible damage that could be done if the cookie is intercepted by some hacker. Once the cookie has expired it is called stale and is automatically destroyed.
Domain Name

The domain name, not commonly used, specifies a general domain name to which the cookie should apply. It allows the cookie to be shared among multiple servers instead of just the one you are on. If you do not use the full http://domain syntax, then a leading dot must precede the domain name.
Format

; domain=.domain_name
; domain=http://somedomain.com


Example:

; domain=.kajinsky.com
; domain=http://kajinksy.com


Path

The path is used to specify where the cookie is valid for a particular server. Setting a path for the cookie allows other pages from the same domain to share a cookie.
Format

; path=pathname


Example:

; path=/home


Security

If a cookie is secure, it must be sent over a secure communication channel (HTTPS server).
Format

; secure

16.3. PHP and Cookies

Now that we have discussed HTTP cookies and their ingredients, it is time to use them with PHP. You will use the same ingredients to make, send, and delete cookies, but all of the underlying details shown in the previous section will be handled with PHP functions.
16.3.1. Creating Cookies with the setcookie() Function

Before creating a cookie, remember that the cookie is part of an HTTP header. Headers must be sent before anything else on the page. One echo statement, even a blank line or space preceding the header will cause an error (see Figure 16.1; see "Buffering and HTTP Headers" on page 689).

Figure 16.1. Sending output before headers is an error.


A cookie is created with the PHP built-in setcookie() function, which takes at least one argument, the name of the cookie. (If only the name argument is present, the cookie by that name will be deleted from the remote client.) The second argument is the value that will be stored in the cookie such as a username, date, e-mail, and so on. It is not a good idea to put any kind of sensitive personal information in cookie files because cookie files are readable text files.

Other optional arguments include the expiration date of the cookie, and the path where the cookie is valid, and lastly, whether or not to make the cookie secure. If you do not set the expiration date, the cookie will be removed when the browser session ends. To skip an argument you can use the empty string (""), but you must use zero (0) to skip the expire and secure arguments because their values must be integers. The expire argument is an integer representing the time in seconds as returned by the time() or mktime() functions. The secure argument indicates that the cookie should only be transmitted over a secure HTTPS SSL connection. You can check to see if the page is being sent over an SSL connection by checking the $_SERVER['HTTPS'] superglobal array, as follows:

if ($_SERVER['HTTPS'] == 'on') { }


If necessary, you can send more than one cookie by using more setcookie() function calls, but remember that the protocol has a limit of 20 cookies from one site to a single user. (For storing more than one value in a cookie, you can use an array. See "Storing Multiple Values in One Cookie—Serialization" on page 681.)
Format

boolean setcookie ( string name [, string value [, int expire [,
string path [, string domain [, int secure]]]]] )


Example:

setcookie("cookie_name", "value");
setcookie("uid", $uid, time() + 60 * 60 * 24 * 60, "/mydir",1);


When you name the cookie, follow the same conventions as you would when creating any PHP variable; that is, no spaces or odd characters. For example, you cannot use whitespace, semicolons, pipe symbols, or commas in the name of the cookie.

The cookies are stored in the PHP global $_COOKIE array. The server variable, $_SERVER['REQUEST_TIME'], gives the time when a request started.
The $_COOKIE Global Array

Once the server has set a cookie, the browser sends it back to the server every time the page loads. When you start your browser, if there are cookies, they pertain to the current page. When a cookie is set, PHP assigns it to the global $_COOKIE associative array, consisting of key=value pairs where the keys are the names of all the cookies and the values are what is stored in the cookie, such as a session ID number, a user ID, e-mail, and so on. (You can only get those cookies that were written for the server you are on and belong to you. You cannot read and write cookies that belong to someone else or reside on a different server.)

To see all the cookies on a page, extract the contents of the $_COOKIE array. When you reload the page, the $_COOKIE array will contain all the cookie values saved for that page. When retrieving cookies, you can check to see if the cookie was set with the built-in isset() or empty() functions, as shown in Example 16.1.

Example 16.1.

   <?php
1      setcookie("usr","Ellie Quigley");
2      setcookie("color","blue");
   ?>
   <html><head><title>The Cookie Array</title></head>
   <body bgcolor="lavender">
   <font face="verdana" size='+1'>
   <h2>$_COOKIE[]</h2>
   <?php
3      if(! empty($_COOKIE['color'])){
          echo "<pre>";
4         print_r($_COOKIE);
          echo "</pre>";
       }
   ?>
   </font>
   </body>
   </html>


Explanation

1	The first cookie key–value pair is set. The name of the cookie is "usr" and the corresponding value is "Ellie Quigley".
2	The second cookie key–value pair is set. The name of the cookie is "color" and the corresponding value is "blue". Normally, the user would provide the value from a form.
3	Because cookies will not become visible until the next loading of the page where the cookie should be visible, you can test if a cookie was successfully set before extracting its contents. See Figure 16.3.
4	The print_r function displays the contents of the cookie. If the cookie had not been set or had expired there would be no output (see Figure 16.2). All the other attributes set for the cookie, like expiration date, path, security, and so on, are not visible.

Figure 16.2. The first time the page is viewed the $_COOKIE array is empty.


Figure 16.3. When the page is refreshed, the $_COOKIE array has cookie values.


Figure 16.4. The browser sends the cookie back to the server; the server sets the cookie in a header. See Figure 16.5, a diagram illustrating server/browser/PHP interaction with cookies.

[View full size image]

Figure 16.5. The cookie is sent in an HTTP header.

[View full size image]

Storing Multiple Values in One Cookie—Serialization

The setcookie() function accepts one string as its value. In the previous example, the setcookie() function was called twice to register two cookie values. Because the number of cookies is limited to 20 per domain, you might want to assign multiple values to one cookie, for example, data coming in from a form. In the following example, one cookie will store three values. This example demonstrates how to serialize data. Serializing the data allows you to convert an array into a string that will be accepted by the cookie. After retrieving the cookie contents, you will have to unserialize it to convert the string back to an array.

The PHP serialize() function returns a string containing a byte-stream representation of the value, making the value acceptable for storage anywhere—in this example, a cookie, though serialization is also used for storing variables and objects in a file or database. (If you go to your browser and look at the actual data stored in the cookie, it has been URL-encoded.)

Use unserialize() to return the string to its orginal form.
Example 16.2.

Code View: Scroll / Show All

   <?php
1      $info = array("ellie", "yellow", 22);
2      setcookie("usr", serialize($info));
   ?>
   <html><head><title>Multiple Cookie Values</title></head>
   <html><head><title>The Cookie Array?</title></head>
   <body bgcolor="lavender">
   <font face="verdana" size='+1'>
   <h2>$_COOKIE[]</h2>
   <pre>
   <b>
   <?php
3      if(! empty($_COOKIE['usr'])){
4         $cookie_data= $_COOKIE['usr'];
5         $cookie_data=stripslashes($cookie_data);
6         $cookie_data=unserialize("$cookie_data");
          echo "What's in the cookie array< br />";
7         print_r($_COOKIE);
          echo "<pre>Unserialized data< br />";
8         print_r( $cookie_data);
       }
   ?>

   </b>
   </pre>
   </font>
   </body>

					  


Explanation

1	The array is assigned a list of values.
2	The setcookie() function is given the name of the cookie followed by the value. The value is an array that is serialized into one string. The new string will be in a format that is acceptable for any type of storage. It represents the data type and number of characters in the original data. a:3 means a three-element array, s:5 a 5-character string, and so on, as shown in the output of this program. By serializing the array into one string, we only need to call setcookie() once.
3	Check to see if the cookie has any value, that is, if it was set.
4	The cookie data is retrieved for the user and assigned to $cookie_data. It is a serialized string. See Figure 16.6.
5	The slashes are stripped from the string. If you do not remove the backslashes, the unserialize() function on the next line fails.
6	The unserialize() function returns the original array.
7	You can see in the value of the cookie the serialized array.
8	The unserialized array is printed. We now have the original values back. See Figure 16.6.

Figure 16.6. Storing an array in a single cookie.

[View full size image]

16.3.2. Tracking Visitors with Cookies

The following examples demonstrate the use of cookies for tracking vistitor activities, such as when the visitor last viewed the page and how many times he or she has been there, but they can also be used to check user preferences, user IDs, and so on. Cookies are useful for retaining small amounts of information, but not all browsers support cookies and if they are supported, a user can turn them off. To overcome these problems, a better solution is to use PHP sessions (discussed in "What Is a Session?" on page 694 of this chapter).
Visitor Count Example

The following example uses a cookie to count the number of times the user has visited this page. Once the cookie is set, its value will be increased by 1 each time the visitor comes back to the page.

Example 16.3.

   <?php
1      $count = $_COOKIE['visits']; // Accessing the cookie value

2      if( $count == ""){
3          $count = 1; // Initialize the counter
       }
       else{
4          $count++;
       }
5      setcookie("visits",$count); // "visits" is the cookie name
   ?>
   <html><head><title>Setting Cookies</title></head>
   <body bgcolor="lavender">
   <font size=+1 face="arial">
   <h2>Visitor Count with Cookies</h2>
   You are visitor number <?php echo $count; ?>.<br />
   </font>
   </body>
   </html>


Explanation

1	The value stored in the $_COOKIE array is extracted and assigned to $count. The value is just an integer that continues to be incremented by 1 each time the user reloads the page. If this is the first time the page has been loaded, the $_COOKIE array will be empty.
2, 3	If this is the first time the user has visited this page, $count will be empty, and it will be set to 1. See Figure 16.7.
4	For each subsequent visit to this page, the value of the counter will be increased by 1. See Figure 16.8.
5	The setcookie() function sets the cookie when the page is first loaded. The name of the cookie is visits and the value stored there will be incremented by 1 each time the page is revisited. The cookie is stored on the user's browser and will be deleted when the browser is exited. What is important to note here is that the cookie is sent in a header, and headers must be sent before any other output from this page. The HTML output is placed after this line or PHP will send warnings to the screen.

Figure 16.7. Cookies used to count visitors.


Figure 16.8. The cookie value is incremented each time the page is reloaded.


Tracking the Visitor's Last Visit

The following example keeps track of when a visitor last viewed the page. The cookie will store the current date, which will be retrieved the next time the page is refreshed.

Example 16.4.

Code View: Scroll / Show All

(Page 1--The HTML page)

    <html><head><title>Setting Cookies</title></head>
    <body bgcolor="lavender">
    <font size=+1 face="arial">
    <h2>Tracking Visitors with Cookies</h2>
    <H1>Welcome to our Site!</H1>
    <p>
1   Check out our product line
        <a href="http://localhost/exemples/sessions/message.php">
        Click here</a>
    </font>
    </body>
    </html>
---------------------------------------------------------------------
(Page 2--The PHP Script--Set a Cookie)

    <?php
        // Filename: "message.php"
2       $date_str="l dS \of F Y h:i:s A";
        $last_visit="Your last visit was on ". date("$date_str");
3       setcookie("message","$last_visit");
    ?>
    <html><head><title>Products</title>
    </head>
    <body bgcolor="lavender">
    <font face="verdana" size='+1'>
    <h2>Products Page</h2>
    <!-- Rest of page goes here -->
    <?php
4       if(! empty($_COOKIE['message'])){ // Has the cookie been set?
5            $when="$_COOKIE[message]";
            echo $when,".< br />";
        }
    ?>
    </font></body></html>

					  


Explanation

1	When the user clicks on the link in this HTML form, he or she will be directed to the page (page 2) that contains the code for setting a cookie. The initial form is shown in Figure 16.9.
2	After clicking the link (Figure 16.9) in page 1, the user is directed to page 2, the "Products Page" (Figure 16.10). The variable is assigned a string of arguments that will be sent to the PHP date() function on the next line, the current date and time on the server. (Keep in mind that the date on the browser and server might not be in sync.)
3	The cookie is set with the setcookie() function. The first argument, "message", is the name of the cookie and the second argument, "$last_visit", is the value that will be stored in the cookie.
4	The first time this page is accessed the cookie is set. Its value will not be available until the next time the page is viewed. If the cookie has a value (i.e., is not empty), the message will contain the date string that was assigned to the cookie by the setcookie() function in the previous viewing of the page.
5	The value of the cookie is extracted. It is the date string that was assigned to the cookie the last time the visitor viewed this page. Every time the visitor refreshes this page, the value of the cookie will be the cookie value that was set on his or her last visit, that is, the date and time of the last visit.

Figure 16.9. The HTML initial form (page 1).

[View full size image]

Figure 16.10. After returning to this page, the cookie value is displayed.

[View full size image]

16.3.3. Extending the Life of a Cookie

How long will a cookie stay in the cookie jar? Normally a cookie expires when the browser is exited. However, the cookie's life span can be controlled by setting the expiration date in the cookie's expire attribute, the third argument in PHP's setcookie() function. The time the cookie expires is represented as a UNIX timestamp; that is, the number of seconds since January 1, 1970, 00:00:00 GMT, known as the epoch. The time() function will give you the current time in seconds, and by adding additional seconds, you can set the expiration date of a cookie to some time in the future. By subtracting from this value, the time will be past time, which will cause the cookie to be deleted. The time returned is expressed in GMT time, the required format for the expire attribute.

To get the time, two PHP functions are provided: time() and mktime().
The time() Function

The time() function returns the current time in UNIX time (UNIX timestamp). By adding the number of seconds to the output of the time() function, you can set the amount of time from now until some future time when the cookie is to expire.

Table 16.1. Units of Time in Seconds
Unit of Time	Seconds
Minute	60
Hour	60 * 60
Day	60 * 60 * 24
Week	60 * 60 * 24 * 7
Month	60 * 60 * 24 * 30

Format

int time ( void )


Example:

$nextWeek = time() + (60 * 60 * 24 * 7);
            (60  seconds * 60 minutes * 24 hours * 7 days)


Example 16.5.

   <?php
       $date_str="l dS \of F Y h:i:s A";
       $last_visit="Your last visit was on ". date("$date_str");
1      $expire=60*60*24*30 + time(); // One month
2      setcookie("message","$last_visit", $expire);
   ?>


Explanation

1	The variable is assigned the value of one month, 30 days, from now in milliseconds.
2	The setcookie() function is named message, it contains the date of the last visit, and it will expire in one month. The expire value is calculated by adding the number of seconds in a month to the current time (time()). After one month, if the visitor returns, the cookie will be reset.

The mktime() Function

The mktime() function will also get the UNIX time. It has a different format. Arguments can be set to 0 (zero) from left to right if you want to use the default values. However, you can leave out arguments on the right side to get the defaults. (The year is either two or four digits.)
Format

int mktime ( [int hour [, int minute [, int second [, int month [,
             int day [, int year [, int is_dst]]]]]]] )


Example:

$lastday = mktime(0, 0, 0, 6, 0, 2006);            // Last day of May
echo date("M-d-Y", mktime(0, 0, 0, 1, 1, 2006));   // "Jan-01-2006"


16.3.4. Buffering and HTTP Headers

Because cookies are sent in an HTTP header, you cannot execute any other output before sending the header or you will get a PHP warning. In the following example, the fact that there is a blank line at the top of the file caused the warning. The cookie headers must be set first unless you turn on buffering.

Example 16.6.

                         <--this blank line caused a warning !!!
<?php
    setcookie("usr","Ellie Quigley");  // Headers must be sent first
    setcookie("color","blue");
?>
<html>
<head><title>The Cookie Array?</title></head>
    <body bgcolor="lavender">
     < Code continues here >
    </body>
</html>


Explanation

The header information must be sent first, or a warning is issued, as in Figure 16.11. Even a blank line will cause a warning.

Figure 16.11. Header information should be sent first!

[View full size image]

If you need to precede any HTTP headers (not just cookie headers) with other output, PHP provides a set of buffering functions that allow you to save all the script's output in a buffer until the script ends (starting with PHP 4.0). When the script ends, first the HTTP headers, and then the contents of the output buffer, are sent to the browser.

The functions that help you control output buffering are shown in Table 16.2.

Table 16.2. Buffering Functions
Function	What It Does
ob_start()	Enables output buffering. No output is sent from the script (other than headers). It is saved in an internal buffer.
ob_end_flush()	Flushes the output buffer, and disables output buffering.
ob_end_clean()	Cleans the output buffer without sending it, and disables output buffering.
ob_get_clean()	Returns the contents of the output buffer and ends output buffering
ob_get_length()	Returns the length of the output buffer.
ob_get_contents()	Returns the current output buffer as a string. This allows you to process whatever output the script emitted.
ob_gzhandler()	A callback function for ob_start(). Useful for sending compressed data.

The ob_start() and ob_end_flush() Functions

The ob_start() function enables output buffering and the ob_end_flush() function flushes out the buffers and then turns buffering off. When your script ends, PHP will automatically flush the buffers, so you can omit ob_end_flush(). It is possible to call ob_start() multiple times; and if so, you would have to call ob_end_flush() for each level.
Format

bool ob_start ( [callback output_callback [, int chunk_size [,
                bool erase]]] )
bool ob_end_flush ( void )


Example:

ob_start();
ob_end_flush();


Example 16.7.

Code View: Scroll / Show All

   <?php
1      ob_start();  // Turn on output buffering
   ?>

   <html><head><title>The Cookie Array?</title>
   </head>
       <body bgcolor="lavender">
       <font face="verdana" size='+1'>
       <h2>$_COOKIE[]</h2>

   <?php
2      setcookie("usr","Ellie Quigley");
       setcookie("color","blue");
   ?>

   <?php
       if(! empty($_COOKIE[color])){
          echo "<pre>";
          print_r($_COOKIE);
          echo "</pre>";
       }

   ?>

   </font>
   </body>
   </html>
   <?php
3      ob_end_flush();  // Flush the buffer and end output buffering
   ?>

					  


Explanation

1	The ob_start() function turns on output buffering. Now only HTTP headers will be sent and the rest of the program's output will be saved until the program ends, at which time it will be sent.
2	The setcookie() function can be placed below the other ouput without causing warnings. This output will be sent first due to the buffering set up on line 1.
3	The ob_end_flush() function is not necessary, but is used here to flush out the buffers and end the output buffering for this session.

Output Buffering and php.ini

If you want buffering set for all your PHP scripts, you can enable the php.ini directive output_buffering. If you do, every PHP script will behave as if it begins with a call to ob_start().

From the php.ini file:
Code View: Scroll / Show All

; Output buffering allows you to send header lines (including cookies) even
; after you send body content, at the price of slowing PHP's output layer a
; bit. You can enable output buffering during runtime by calling the output
; buffering functions. You can also enable output buffering for all files by
; setting this directive to On. If you wish to limit the size of the buffer
; to a certain size -you can use a maximum number of bytes instead of 'On', as
; a value for this directive (e.g., output_buffering=4096).
output_buffering = Off

					  


Output buffering is turned off by default. If you want to turn it on for all scripts, go to the php.ini initialization file and change the output_buffering directive to "On".
16.3.5. Deleting a Cookie

When cookies are created, they are, by default, deleted when the user closes his or her browser. You have seen how to expand the life of a cookie, but what if you want to delete the cookie right now, even before the user closes his or her browser? Instead of adding to the current time, you simply subtract from the current time to some earlier date. This will cause the cookie to be deleted right away.

Remember, deleting a cookie is the responsibility of the browser and the time settings there might be different from the time settings on the server. Even though technically setting the expiration time to –1 would be an earlier time, it might be better to set it to a bigger negative number to assure that it will be removed. Setting the expiration time to 0 has no effect.
Example 16.8.

<?php
    setcookie ("cookie_name", "", time( ) - 3600);  // One hour ago
?>


Explanation

Because we are destroying the cookie, there is no point in giving it a value, thus the second argument is intentionally left empty.
Using the Browser to Remove Cookies

Another way to delete cookies is to go in your browser to the Tools menu in Navigator, then to the Cookie Manger, and then to Manage Stored Cookies. In Internet Explorer, go to the Tools menu and Internet Options. Then you can remove all or some cookies from the hard drive. Figure 16.12 shows you how the Firefox browser manages cookies by going to Tools, Options, Privacy.

Figure 16.12. Cookie management on the Firefox browser.

[View full size image]

	
16.4. What Is a Session?

Simply put, a session is the time that a user spends at a Web site. PHP provides us with a mechanism to manage sessions so that we can keep track of what a visitor is doing, what he or she likes, what he or she wants, and so on, even after the user logs off. Like cookies, the idea is to maintain state. Before delving into the details, let's use an analogy to give you an idea of how sessions work.

Imagine taking your favorite wool sweater to a dry cleaning establishment. You will drop off the sweater and be handed a claim ticket that will be used to identify the sweater when you return. The other half of the claim ticket is pinned to your sweater with the same number you have on your claim ticket. Later when you come back, you will give your claim ticket to the attendant and he or she will use it to identify your sweater in the long rack of clothes. A session works the same way.

A PHP session, like a cookie, is a way for the PHP to keep track of that Web site visitor even after he or she leaves or logs off. A visitor makes a request from his or her browser to retrieve a Web page as follows:

http://server/homepage.php


The server program, in this example, homepage.php, is a PHP program. PHP starts a session and sends a unique session ID number, similar to the claim ticket, back to the visitor's browser. This unique ID number is a long random hexadecimal number that is used to key into the user's data. It can be sent via a cookie or added to all URLs of the pages for the site. The actual user information is saved in a session file on the server, usually in a temporary directory (see Figure 16.13). The session filename contains the unique ID number for the session. The next time the visitor asks for the page, his or her browser hands the ID number back to the server, just as you hand the claim ticket to the dry cleaning attendant. The server uses the session ID number to locate the file with the name that corresponds to the same session ID number. The session file contains the actual session data; for example, username, preferences, or items in the shopping cart—information about the visitor that was stored the last time he or she visited the page. If this is the first time the user has visited the page, his or her preferences will be collected and stored into the session file, to be retrieved later on.

Figure 16.13. The session data is stored in a /tmp directory on the server.

[View full size image]

By default, the session ID is sent in a cookie and the cookie's name is PHPSESSID. Unlike the cookies we discussed in the first part of this chapter, where the user information was passed in a cookie, with sessions, the only data in the cookie is the session ID, not any other information about the user. The user information is saved in a session file on the server so that the size limitation of cookies is not a factor and sensitive information is not being passed back and forth across the network.

This session file starts with "sess" followed by the session number (Apache/Windows). The text it contains is a serialized line representing the data, the data type, and the number of characters saved for a session.[2] This is a line from a session file:

    [2] Because the (session) library uses different storage modules, you can keep the data in plain-text files, shared memory, or databases. The exact location of data is not really important (as long the performance of the medium is sufficient). From Tobias Ratschiller, http://www.zend.com/zend/tut/session.php.

book|s:7:"History";user|s:13:"Ellie Quigley";


Once the user's browser has a session ID, it passes that ID back to the server program on every subsequent request. The session ID is disposable, so after some time it will expire and the information associated with it will also be removed. A session might last for a few minutes or a few hours since the last request or it could last indefinitely. We look at various configuration options later in this chapter. Figure 16.14 illustrates the way the session ID is passed in a cookie.

Figure 16.14. The cookie file and the session file have the session ID in common.

[View full size image]

Although cookies are the default way to pass the session ID back and forth between browser and server, you can also pass the session ID as GET or POST data in the same way as when submitting a form. Recall that GET data is URL-encoded and attached with a ? to the URL, whereas the POST data is part of the page header information. It is also possible to send a session ID through a URL with a link within a page.
16.4.1. Where to Store Sessions

If your site is sharing a server, it is recommended that session files for users should be in their own user area under the server, but not in a world writable directory such as /tmp. If a site has a large number of users and session files, it is possible to store the session files in multiple levels of subdirectories. To find out where your sessions are stored, or to change the default path, see session.save_path in the php.ini file or use PHP's session_save_path() function.

From the php.ini file:

; session.save_path = "N;/path"
;
; where N is an integer. Instead of storing all the session files in
; /path, what this will do is use subdirectories N-levels deep, and
; store the session data in those directories. This is useful if you
; or your OS have problems with lots of files in one directory, and is
; a more efficient layout for servers that handle lots of sessions.
;


The session_save_path() function returns the path of the current directory used to save session data. If a path is specified, the path to where data is saved will be changed for this session. If this page will be linked to other pages, then the function must be called before starting the session in all the pages involved. Of course, PHP will need read and write access to the new path to retrieve and save session data.
Format

string session_save_path ( [string path] )


Example:

session_save_path("/newpath");
echo session_save_path();


Example 16.9.

   <?php
       echo "Your session files are stored in <b>".
1         session_save_path(). ".</b>< br />";
2      if ($handle = opendir(session_save_path())) {
           echo "<b>Files:< br />\n";
           /* Loop over the directory. */
3          while (false !== ($file = readdir($handle))) {
              echo "$file< br />\n";
           }
           echo "</b>";
           closedir($handle);
       }
?>


Explanation

1	The session_save_path() function returns the path location where the session files are stored.
2	The opendir() function opens the directory folder where the session data is stored and returns a handle to that directory, $handle.
3	The readdir() function retrieves the contents of the directory, and its output is displayed in Figure 16.15.

Figure 16.15. The session path and files. Output from Example 16.9.

[View full size image]

16.4.2. Starting a Cookie-Based Session

A PHP session is started either explicitly with the session_start() function, or implicitly by registering a variable for the session with the session_register() function. Typically, session_start() is called on top of the page, and then session variables are registered in the superglobal $_SESSION array.

When PHP starts a session, it has to check first to see whether a valid session ID already exists for this user. If a valid session ID does exist, PHP will go to the session file that corresponds to the ID number, retrieve the data from the file, and assign it to the superglobal $_SESSION associative array. The values in this array are then made available to your program. If this is the first time the user has visited the page, PHP will create a new session ID, and the $_SESSION array will be empty.
The session_start() Function

The session_start() function creates a session or resumes one that has already started. The session ID is passed via a cookie, via GET/POST, or in a link (see a cookie-based session in Figure 16.16). Each page that uses a session must start the session with the session_start() function. If the session ID is being sent by a cookie, then as with all cookie headers, the session_start() function is called before any other statements that send output to the browser. This function always returns TRUE.

Figure 16.16. A cookie-based session. Note the session ID is sent as an HTTP Cookie header.

[View full size image]

Format

bool session_start ( void )


Example:

session_start();


16.4.3. Registering a Session

The data that is stored in the session file is created in a PHP script in the form of variables. The session variables can then be referenced across page requests during the life of a session. These variables might represent the items placed in a shopping cart, a user's login and password, a user's color preference, and so on.

Although session_start() starts a session, it does not register session variables. To create session variables, you must register the variables in the session library. This can be done in two ways. We address both methods next.
The $_SESSION Associative Array

To register variables for the session, the preferred way is to assign values to the superglobal $_SESSION array. Superglobals are available everywhere in your script, even within functions. PHP automatically registers the $_SESSION variables for you. The global $_SESSION associative array is used to handle the session variables that will be saved on the server for the life of the session. The key for the $_SESSION associative array is the name of the variable, and the value is what you are assigning to it.

To access the values in the $_SESSION associative array, you must first start a session and then extract the array values as you would any other associative array.

To unset these variables, the unset() function is used; for example, unset($_SESSION['color']).

You must use session_start() before using the $_SESSION array.
Format


Example:

$_SESSION['username'] = "john";
$_SESSION['password'] = $_POST['passwd'];


Example 16.10.

   <?php
1      session_start();
   ?>
   <html><head><title>Sessions</title></head>
   <body bgcolor="lavender">
   <font size=+1 face="arial">
   <h2>Tracking Visitors with Sessions</h2>
   <?php
2      if ( ! isset($_SESSION)){
3         $_SESSION[visitor_count]=0;
       }
       else{
4         $_SESSION[visitor_count]++;
       }
5      echo "You are visitor number ",$_SESSION['visitor_count'],".
       <br />";
6      echo "The session id is: ",session_id();
   ?>
   </font>
   </body>
   </html>


Explanation

1	The session is started here. All scripts using sessions start with the session_start() function.
2	If the session variable has not been set, this is the start of a brand new session. A session ID will be assigned and the $_SESSION array will be initialized on the next line.
3	The key in the $_SESSION associative array is visitor_count. The value assigned to it is 0.
4	Once the user refreshes this page, the value of the $_SESSION is incremented by 1 (see Figure 16.17).
5	Every time the visitor returns to this page, the count is incremented by 1 and this line displays the output, as shown in Figure 16.18.
6	The session_id() function returns the value of the current session ID.

Figure 16.17. Using the $_SESSION array to save and retrieve a session. Initial output from Example 16.10.

[View full size image]

Figure 16.18. Each time the user refreshes this page, the count is incremented by 1.

[View full size image]

The session_register() Function

The traditional way to register session variables was to use the PHP session_register() function, but to use this function you must set register_globals to "On" in the php.ini file, no longer the default setting. If, on the other hand, you are using the session_register() function, once registered in the session library, these global variables will be available until the session ends or until the session_unregister() function is called. Unlike registering session variables with the $_SESSION array, with the session_register() function it is not necessary to call session_start() first. After registering a variable, PHP will make an implicit call to session_start().

The arguments to session_register() can be strings containing the name of a variable or an array name. Note that this function takes the name of a variable as argument, not the variable itself.

The session_is_registered() function can be used to check if a session variable has been set and session_unregister() to remove variables from the session; for example, to remove a product item from the shopping cart. These functions should not be used if you are registering sessions with the $_SESSION array.
Format

bool session_register ( mixed name [, mixed ...] )


Example:

session_start();
session_register('username');
session_register('password');


16.4.4. Saving Arrays in a Session

When using a shopping cart, you can add multiple items to your cart, browse around, come back, delete some items, and go on like this until you submit your order. A program that collects this data can store it in an array and save the data with a session. The $_SESSION array accepts simple scalar variables, but can also accept arrays. The following example demonstrates how to register multiple items in a session, list the saved values on another page, return to the selection page, and add more items to the array.
Example 16.11.

Code View: Scroll / Show All

   (Page 1)
   <?php

1      session_start();
2      if ( ! isset($_SESSION['choices'])){
3         $_SESSION['choices']=array();
       }
4      if ( is_array( $_POST['books'])){
5         $items=array_merge($_SESSION['choices'], $_POST['books']);
6         $_SESSION['choices'] =array_unique($items);
7         header("Location: listing_page.php");   // Redirect to this
                                                  // page now!
       }
   ?>

   <html>
   <head><title>Arrays and Sessions</title></head>
   <body bgcolor="#6666ff">
   <font face="verdana" >
   <div align="center">
8  <form action="<?php echo $_SERVER['PHP_SELF']?>" method="POST">
   <p>
   Book Categories< br />
9  <select name="books[]" multiple=multiple size="8">
       <option>Art</option>
       <option>Computer</option>
       <option>Engineering</option>
       <option>Fiction</option>
       <option>Language</option>
       <option>Non Fiction</option>
       <option>Poetry</option>
       <option>Travel</option>
   </select>
   </p>
   <input type=submit value="Select category"/>
   </p>
   </font>
   </body>
   </html>

					  


Explanation

1	A session for this page is started. All scripts that use sessions must call the session_start() function.
2, 3	If this is the first time the visitor has viewed this page, the session variables will not be set. In line 3 the array() function makes sure the $_SESSION['choices'] array is created with no values.
4	If the form has been submitted, $_POST['books'] will contain a list of the books selected from the menu in the form.
5	The array_merge() function joins the values in $_SESSION['choices'] and the books that were listed in the form, $_POST['books']. If this is the first time the user has visited the page, the $_SESSION[] array will be empty, but it will exist because it was set to the empty array on line 3.
6	If this is not the first visit and the $_SESSION['choices'] array has values from a previous session, the array_unique() function will remove any duplicates that might occur after the merge on line 5.
7	The visitor is redirected to page 2, listing_page.php, to see his or her currently saved selection of books.
8	This is a self-processing form. Once the visitor has filled out the form, the PHP code on this page will process it and then redirect the user to page 2.
9	The HTML selection list is named "books[]" (shown in Figure 16.19), the name of the array PHP will use to collect the visitor's book choices.

Figure 16.19. Page 1: The visitor selects some books.


Example 16.12.

Code View: Scroll / Show All

   (Page 2)
   <?php
1      session_start();
   ?>

   <html><head><title>Listing User's Book Categories</title></head>
   <body bgcolor="#6666FF">
   <font face="verdana">
   <table width="25%" border='1'>
   <caption><b>Selected Book Categories</b></caption>
   <col span="1" width="100"/>
   <?php
2      if ( is_array($_SESSION['choices'])){
3         foreach($_SESSION['choices'] as $book){
   ?>
4      <tr bgcolor="#ffffff"><td ><?php echo $book ?></td></tr>
   <?php
           } // End foreach block
         } // End if block
         else{ echo "<p>You have not selected any book categories
               yet</p>";}
   ?>
   </table>
   <p>
5  <a href="selections_page.php">Click here to return to category
            page</a>
   </p>
   </font>
   </body>
   </html>

					  


Explanation

1	A session is started for this page.
2	If $_SESSION['choices'] has values, then the user has selected books in a previous session, and the statements in the if block will be executed.
3	The foreach loop is used to iterate over the array and list each of the books in the $_SESSION['choices'] associative array.
4	The books selected by the user are displayed in the table shown in Figure 16.20.
5	This link is used to send the user back to the first page, shown in Figure 16.21. After selecting another book item from the Book Categories in the original form, the new selection is saved by the session and redisplayed in Figure 16.22.

Figure 16.20. Page 2: This page lists the user selections saved in the session.


Figure 16.21. Page 1: User returns to selection page and adds another item.

[View full size image]

Figure 16.22. Page 2: User added another item to his or her list. Previous selections were saved in the session.


16.4.5. Session Cookie Functions and Configuration Options

Some developers feel that it is better to enforce the use of cookies rather than rely on passing sensitive session information through URLs (see "Passing Session IDs with a Link" on page 721), and because the default method of passing session IDs back and forth from browser to server is through cookies, PHP provides specific cookie functions to handle the cookie-based sessions.

To set the cookie parameters use the session_set_cookie() function, similar to the way we used the setcookie() function when working strictly with cookies, not sessions.

The effect of this function lasts only for the duration of the script. Thus, you need to call session_set_cookie_params() for every request and before session_start() is called.
Format

void session_set_cookie_params ( int lifetime [, string path [,
                                 string domain [, bool secure]]] )


Example:

$expire=60*60*24*60 + time();  // Two months
session_set_cookie_params($expire, "/", "abc.com", 1);


Not only are there a number of functions to handle cookies, but you can also set specific directives in the php.ini file that affect the cookies for all of your scripts.

The ini_set() option can be used in a script to change the value of a configuration option just for the duration of the session; for example, the following header file enforces the use of cookies so that the user must have cookies enabled in his or her browser:

ini_set('session.use_cookies', 1);
ini_set('session.use_only_cookies', 1);
session_start();


Table 16.3. Cookie Configuration Directives (in the php.ini File)
Directive	What It Does
session.cookie_lifetime	Specifies the lifetime of the cookie, sent to the browser, in seconds. The value 0 means "until the browser is closed." Defaults to 0.
session.cookie_path	Specifies path to set in session_cookie. Defaults to /.
session.cookie_domain	Specifies the domain to set in session_cookie. Defaults to the host name of the server that generated the cookie.
session.cookie_secure	Specifies whether cookies should only be sent over secure connections. Defaults to off.
session.use_cookies	Specifies whether the module will use cookies to store the session ID on the client side. Defaults to 1 (enabled).
session.use_only_cookies	Specifies whether the module will only use cookies to store the session ID on the client side. Enabling this setting prevents attacks involved in passing session IDs in URLs.

16.4.6. Setting Preferences with Sessions

Consider the following example. One page lets the user select a favorite background color; using the session mechanism, when the user goes to another page, the color is displayed in the new page.
Example 16.13.

Code View: Scroll / Show All

   (Page 1)
   <?php
1      if( isset($_REQUEST['color'] ) ) {
              // Start the new session
2             session_start();
              // Set the favorite color for this user
3             $_SESSION['favorite_color'] = $_REQUEST['color'];
       }
   ?>
   <html>
   <body>
   <h1> Select Favorite Color</h1>
    <select name="color">
4  <form action="<?php echo ${_SERVER}['PHP_SELF']; ?>" method="GET">
   <select name="color" >
       <option value="" selected>Please select</option>
       <option value="white">White</option>
       <option value="blue">Blue</option>
       <option value="red">Red</option>
       <option value="yellow">Yellow</option>
       <option value="gray">Gray</option>
   </select>
   <input type="submit" value="Set color">
   </form>
   </body>
   </html>

					  


Explanation

1	Because this form is submitting to itself, first we check whether the request contains the color variable at all. If there is no color variable, there is no point in processing the form data. The first time the user visits the page, there will be no color variable set because the form has not yet been submitted.
2	Now that we do know that the color is set in the $_REQUEST, we can start the session. We use session_start() function to do so. This function will create a brand new session for this user, or reinstantiate an existing one if the session ID is present in the cookie or POST/GET data.
3	Next we extract the color the user selected from $_REQUEST and record it in the user's $_SESSION associate array. Notice that $_REQUEST is maintained for each request to PHP whereas $_SESSION is maintained for each user. The 'favorite_color' is an arbitrary key that we use to identify this variable in the $_SESSION array. The 'color' key corresponds to the input field in the form on the same page with the name "color".
4	Again, notice that the form action is submitting to itself. We use the property of the $_SERVER variable where the name of the current page is stored in this array under the key PHP_SELF.

Figure 16.23. Page 1: The color is set to "Yellow."


Example 16.14.

   (Page 2)
   <?php
1      session_start();
2      $favorite_color = $_SESSION['favorite_color'];
   ?>
   <html>
3  <body bgcolor="<?php echo $favorite_color;?>">
   <h1>Your Favorite Color</h1>
4  Your favorite color is <b><?php echo $favorite_color; ?></b>.
   </body>
   </html>


Explanation

1	This page will retrieve the user's favorite color from the session. The first step is to start the session using the session_start() function. In this case, session_start() will retrieve the $_SESSION array for this user based on the current session ID (created in the previous page).
2	Once the session starts, the global $_SESSION array corresponding to this user can be accessed. The key–value pair of the $_SESSION array consists of favorite_color, the key, and the color, yellow, that was selected from the previous page. If the previous page had not been viewed, $_SESSION would not have any session values.
3	The value of $favorite_color is assigned to the <body> of this page to customize the background color for this user.
4	This line prints the favorite color just to confirm that the selected color was passed to this session.

Figure 16.24. Page 2: The session is used to "remember" the user's preference.


Notice that in this example the only connection between the page that sets the color and the page that displays the color is the session. Unlike forms where one page collects the information and passes it to another page via a GET/POST request, the session pages need not be connected. In other words, we can set the color, then surf anywhere else and once we come back, the color should still be set.

Note that this "stickiness" is valid only as long as the session is valid. A typical session might expire within an hour or two, or never. This is configured in the php.ini file and is up to the server setting to manage it. Also, if the user restarts the computer or the Web browser, his or her session ID might be lost and the next visit to these pages will create a brand-new session.
Remembering Users and Preferences over Multiple Pages

The following example consists of three pages: the HTML form, a file that handles the form data and starts a session, and links to another page where the session variables are used. The example demonstrates a session using cookies to pass the form data from page to page.
Example 16.15.

Code View: Scroll / Show All

(Page 1--The HTML Form)
<html><head><title>Sessions</title>
</head>
<body bgcolor="lavender">
<font face="verdana" size="+1" >
<H1>Book Categories</H1>
<form action="sessions.php" method="Post" >
    Your name:
    <br />
    <input type="text" name="user" size="50" />
    <p>
    Select a book category:
    <br />
    <input type="radio" name="book" value="Art">Art
    <br />
    <input type="radio" name="book" value="Computer">Computer
    <br />
    <input type="radio" name="book" value="Drama">Drama
    <br />
    <input type="radio" name="book" value="History">History
    <br />
    <input type="radio" name="book" value="Poetry">Poetry
    <br />
    <input type="radio" name="book" value="Sports">Sports
    <p>
    <br />
    <input type="radio" name="book" value="Sports">Sports
    <p>
    <input type="submit">
</form></body></html>

					  


Explanation

This is the first page, shown in Figure 16.25, of a series of three pages. Once this form is submitted, the file named session.php will be executed.

Figure 16.25. Page 1: The HTML form. The visitor selects a book category.

[View full size image]

Example 16.16.

Code View: Scroll / Show All

   (Page 2--Starting the Session)
   <?php
       session_start();
   ?>
   <html><head><title>Sessions</title></head>
   <body bgcolor="lavender">
   <font face='arial' size="+1">
   <?php
1      if ( ! (empty($_POST['book']) or empty($_POST['user']))){
2          // Create short variables
           $book=trim(stripslashes($_POST['book']));
           // Create short variables
           $user=trim(stripslashes($_POST['user']));
3          if( isset($_SESSION['user'])){
              echo "<H2>Welcome back, $_SESSION[user]!</H2>";
              echo "<H2>You recently visited our $_SESSION[book]
                    store.</h2>";
           }
4          else{
5             $_SESSION['book']=$book;
              $_SESSION['user']=$user;
              echo "<H2>Welcome, $user!</H2>";
           }
       }
       else{ die ("Form incomplete< br />");
       }
       echo "The session id is: ",session_id(),"< br />";
       echo "You have chosen to enter the <b>$book</b>
          section.< br />";
6      $section=$book. "_page.php";  // Creating a variable
   ?>
   To browse the <?php echo $book; ?> Section:
7  <a href="<?php echo $section; ?>">Click here</a>
   < br />
   </body>
   </html>

					  


Explanation

1	If the user has filled out the form properly both the 'book' and 'user' fields will have values and the statements in the if block will be executed.
2	Any slashes or whitespace in the form data are removed. Variables are created from the $POST_[] array.
3	If the visitor has already been to this page, then the session variables will be available, and the statements in the if block will be executed. See Figure 16.28.
4	If this is the first time the user has visited this page, the statements in the else block will be executed. See Figure 16.26 for output.
5	The session variables are assigned the values that came from the form.
6	The name of the selected book and the string "_page.php" are concatenated together as a single string and assigned to the variable $section, which will be the next page where the user will be directed when he or she clicks the link on line 8. (Figure 16.27 displays the page that appears when the user clicks this link.)
7	This link will take the user to his or her book category page.

Figure 16.26. Page 2: The first time the visitor has entered this page. (Note that the session ID is remembered from session to session.)

[View full size image]

Figure 16.27. Page 3: After the visitor clicked on the link in the previous page, shown in Figure 16.26.

[View full size image]

Figure 16.28. The visitor has returned to page 1, filled out the form, and is sent to page 2.

[View full size image]

16.4.7. Naming Sessions

The session name refers to the session ID stored in both cookies and URLs. Instead of using the default name of your session, PHPSESSID, you can give your session a different name. However, remember that if you change the name of the session, every page that uses your application must call session_name() with the new name before calling session_start(). The session_name() function will return the current session name if given no arguments, or reset the session name when the first argument is a string. See also the session.name configuration directive in the php.ini file.
Format

string session_name ( [string name] )


Example:

// Only alphanumeric characters are allowed in the name
// (at least one letter)
session_name("MyKewlSite");
session_start();


Example 16.17.

Code View: Scroll / Show All

   (Start the session on this page)
   <?php
   obstart();
   if( isset($_REQUEST['color'] ) ) {
       // Start the new session with a new name
1     print "The previous session name was ". session_name() .
            ".< br />";
2     session_name("ColorSite");
      print "The new session name was ". session_name() . ".< br />";
3     session_start();

      // Set the favorite color for this user
      $_SESSION['favorite_color'] = $_REQUEST['color'];
   }
   ?>

   <html>
   <body>
   <h1> Select Favorite Color</h1>
4  <form action="<?php echo ${_SERVER}['PHP_SELF']; ?>" method="GET">
   <select name=color>
       <option value="" selected>Please select</option>
       <option value="white">White</option>
       <option value="blue">Blue</option>
       <option value="red">Red</option>
       <option value="yellow">Yellow</option>
       <option value="gray">Gray</option>
   </select>
   <input type="submit" value="Set color">
   </form></body></html>
   <?
----------------------------------------------------------------------
   (This page uses the new name)
   <?php
5      session_name('ColorSite');
6      session_start();
       $favorite_color = $_SESSION['favorite_color'];
       print_r($_SESSION);
   ?>
   <html>
   <body bgcolor="<?php echo $favorite_color; ?>">
   <h1>Your Favorite Color</h1>
   <font size='+2'>
   Your favorite color is <b><?php echo $favorite_color; ?></b>.
   </font></body></html>
   <?php
       ob_end_flush();  // Flush the buffer and end output buffering
   ?>

					  


Explanation

1	Before changing the name of the session, the session_name() function returns the name of the current session.
2	The session_name() function will change the name of the session to ColorSite. Now any page using this session will also need to call session_name('ColorSite') before starting a new session.
3	A session is started for this page. The session's name is "ColorSite".
4	This is a self-processing PHP script. It will present the form and then process it.
5	To use the session ID from the previous session, this page needs to be able to refer to the correct session by its name.
6	A new session is started after the session name was changed. See the output in Figure 16.29.

Figure 16.29. Changing the session's name. Output from Example 16.17.

[View full size image]

16.4.8. Sessions Without Cookies

As we have seen in the previous examples, a cookie is used to hold the session ID. This is the default and considered the most secure way to handle session data. The problem with cookies, however, is that the user can disable them for his or her browser or refuse to accept them. To overcome the obstacle of a cookieless client, the other way to send the session ID is in the URL or by using hidden fields with GET/POST.

When propagating the session ID with GET/POST, it must be done only when the URL resides on your local Web server and is not passed to an external URL.
Using a Hidden Form Element

When working with HTML the session ID can be propagated through the use of a hidden form element. When assigning the name and value to the hidden input device, the name will be the name of the current session and the value, the session ID. You can use the session_name() and session_id() functions to get the those values. The SID constant can also be used to get the current session ID. For example:

<FORM ACTION="order.php" METHOD=GET>
<INPUT TYPE="hidden" NAME="<?php echo session_name(); ?>"
                     VALUE="<?php echo session_id(); ?>">
<!-- The remainder of the form HTML code //-->
</FORM>


Example 16.18.

Code View: Scroll / Show All

   (Page 1)
   // Disable cookies for this session
1  ini_set('session.use_cookies', 0);
2  ob_start();

   /* start the session */
3  session_start();

4  if( isset($_REQUEST['mycolor'] ) ) {
5      $_SESSION['favorite_color'] = $_REQUEST['mycolor'];
6      $sess_name=session_name();
7      $sess_id=$_REQUEST[$sess_name];
8      header("Location:other_page.php?$sess_name=$sess_id");
   }
   ?>
   <html>
   <body>
   <h1> Select Favorite Color</h1>

9  <form action="<?php echo ${_SERVER}['PHP_SELF']; ?>" method="GET">
   <select name="mycolor">
   Please select</option>
       <option selected value="green">Green</option>
       <option value="white">White</option>
       <option value="blue">Blue</option>
       <option value="red">Red</option>
       <option value="yellow">Yellow</option>
       <option value="gray">Gray</option>
   </select>
10 <input type="hidden" name='PHPSESSID'
11       value="<?php echo session_id();?>">
   <input type="submit" value="Set color">
   </form>

   </body>
   </html>
   <?php
       ob_end_flush();
   ?>

					  


Explanation

1	The ini_set() function is used to change the configuration value for the duration of this script, in this case to temporarily disable the use cookies. The session will try to use them if they are not disabled. (Note: Make sure that your browser also has cookies disabled.)
2	The ob_start() function turns on output buffering.
3	The session_start() function creates a session or resumes the current one based on the current session ID that is being passed via a request, such as GET, POST, or a cookie.
4	If the HTML form has been submitted, the variable $_REQUEST['mycolor'] has been set and the if block is executed.
5	A session variable called $_SESSION['favorite_color'] is assigned the value of $_REQUEST['mycolor'].
6	The session_name() function returns the name of this session.
7	The value of the session ID is stored in the hidden field in the form. $_REQUEST[$sess_name] is an associative array where the key is the session name, PHPSESSID, and the value is the session ID number, the number visible in the URL when this file is viewed in the browser.
8	The header() function sends an HTTP header—in this example, a redirection header to send the user to the location other_page.php—and passes, as part of the URL, the session ID listed after the ?.
9	The self-processing form starts here; the method is GET. See Figure 16.30.
10, 11	The name and value of the session ID are assigned to a hidden field in the form.

Figure 16.30. The HTML form and self-processing PHP page.

[View full size image]

Example 16.19.

   (Page 2)
   <?php
1      session_start();
2      if ( isset($_SESSION['favorite_color'])){
          print "favorite_color is registered< br />";
3         $color = $_SESSION['favorite_color'];
       }
   ?>
   <html>
   <body bgcolor="<?php echo $color; ?>">
   <h1>Your Favorite Color</h1>
   Your favorite color is <b><?php echo $color; ?></b>.
   <?php
4      unset( $_SESSION['favorite_color']);
5      session_destroy();
   ?>
   </body>
   </html>


Explanation

1	The session is started for this redirection page. It gets the session ID from the URL that pointed to this page.
2	The favorite color of the user is passed in the session variable.
3	The favorite color of the user is assigned as the background color of the page, as shown in Figure 16.31.
4	The unset() function destroys a single session variable.
5	The session_destroy() function removes the entire session.

Figure 16.31. The user is redirected to this page with a location header.

[View full size image]

16.4.9. Passing Session IDs with a Link

If cookies are not available because the user has disabled them, another alternative is to pass session IDs via a link. There are two ways to do this: manually or automatically. The manual way requires that for every relevant page in your site, you attach the session ID to the link and PHP will send it to the linked page. The automatic method requires changing the session.use_trans_sid setting in the php.ini file.
The SID Constant

If you have disabled cookies, the SID constant holds the value of the session ID. If cookies are enabled, this constant is empty.

The SID constant can be concatenated to the URL in a hyperlink to pass it to another page as shown here:

$sid=SID;
<a href="phpscript.php?<?=echo $sid"> Order now!</a>

echo '<a href="checkout.php?' SID . '">Checkout<a/>';


If there are a lot of links in your Web site, automatic URL rewriting is a PHP feature that adds the session ID automatically to all the links within linked the pages. To enable this feature, you need to edit the PHP php.ini configuration file. Look for the line

session.use_trans_sid


and set it to 1, save the changes, and restart your Web server. Then the session ID will be added to all relative links within your PHP pages. Notice that by default this feature is turned off for security reasons, so proceed with caution. There is also a performance cost because PHP has to add the session ID to every page where the link is relative, whereas a cookie is only set once.

From the php.ini file:

; trans sid support is disabled by default.
; Use of trans sid may risk your users security.
; Use this option with caution.
; - User may send URL contains active session ID
;   to other person via. email/irc/etc.
; - URL that contains active session ID may be stored
;   in publically accessible computer.
; - User may access your site with the same session ID
;   always using URL stored in browser's history or bookmarks.
session.use_trans_sid = 1


To summarize, when automatically passing a session ID via a URL, the following should be considered:

   1.

      The browser does not accept cookies.
   2.

      The session.use_trans_sid directive in the php.ini file is set to 1. You will need to restart your Web server for this directive to take effect.
   3.

      The URL in the PHP script must be a relative path name.
   4.

      If using the constant, SID, use striptags(). Remember the SID is not available unless cookies are disabled.

Example 16.20.

Code View: Scroll / Show All

   (Page 1)
   <?php
1      ob_start();  // Turn on output buffering
2      ini_set('session.use_cookies', 0); // Don't accept cookies
   ?>
   <html><head><title>Sessions and Links</title>
   </head>
   <body bgcolor="lavender">
   <font face="verdana" size='+1'>
   <h2>Sessions and Links</h2>

   <?php
3      session_start();
4      $_SESSION['user']="John Doe";
       $_SESSION['color']="aqua";
   ?>

   <?php
5      if(! empty($_SESSION['color'])){
          echo "<pre>";
          print_r($_SESSION);
          echo "</pre>";
6         $sid = session_id();
          echo "SessionID is ", $sid, "< br />";
       }
   ?>
7  <a href="/exemples/sessions/link2file1.php"> Click here</a>
   </font>
   </body>
   </html>

					  


Explanation

1	The ob_start() function turns on output buffering, so that any PHP headers will be sent before the rest of the program's output is sent. Without this function, the program will produce a warning when the program tries to ouput header information:

Warning: session_start() [function.session-start]: Cannot send session cache limiter - headers already sent (output started at c:\wamp\www\exemples\ sessions\session_url.php:11) in c:\wamp\www\exemples\sessions\session_url.php on line 12
2	This directive states that cookies will not be turned on for this session. You can also turn off cookies in your browser, but then they will be turned off until you enable them again.
3	The session_start() function starts a new session and generates a new session ID.
4	The session variables are registered and assigned to the global $_SESSION array.
5	This line checks to see if a session variable has been set.
6	Once the session is started, PHP generates a session ID, shown in Figure 16.32.
7	This link will take the user to the next page. Along with the link, PHP will automatically send the session ID to the file link2file1.php.

Figure 16.32. Page 1: Passing the session ID in a link. Output from Example 16.20.


Example 16.21.

Code View: Scroll / Show All

   (Page 2)
   <?php
1      ini_set('session.use_cookies', 0); // Turn cookies off
2      session_start();  // Start a session
   ?>
   <html>
3  <body bgcolor="<?php echo ${_SESSION}[color]; ?>">
   <h3>
   <?php
4      print_r($_GET);
5      echo "< br />The session id is " , session_id(), "< br />";
6      echo "The session name is " , session_name(), "< br />";
7      echo "SID is ", SID;
   ?>
   </h3>
   <h2>
   Hi <?php echo $_SESSION['user']; ?>. You like <b>
      <?php echo $_SESSION['color']; ?></b>.
8  <a href="/exemples/sessions/link2file2.php">
   Click here</a>
   </h3>
   </body>
   </html>

					  


Explanation

1	For this session, cookies are turned off.
2	The session starts.
3	The session ID was passed in from the link on page 1. The background color of the page is set to the value of the $_SESSION['color'] assigned and registered on page 1.
4, 5	The $_GET[] array contains information coming in from the link; that is, the session name and the session ID. See the first line of output for page 2.
5, 6	The session_id() function returns the value of the session ID that came in from the link on page 1 and the session_name() function returns the name of the session.
7	The constant SID contains the name and ID for the session. This constant is not set if cookies are turned on.
8	Now we link to yet another file. The session ID will be passed through this link. For output of this example, see Figure 16.33.

Figure 16.33. Page 2: The session ID and data passed in from a link in page 1. Output from Example 16.21.

[View full size image]

Example 16.22.

   (Page 3)
   <?php
1      session_start();
2      extract($_SESSION);
3      printf("%s",SID);  // Print the session ID
4      echo "The session id is " , session_id()," < br />";
   ?>
   <html>
   <body bgcolor="<?php echo $color?;>">
   <h2>
5  Hi again <?php echo $user;?>. You still like <b>
            <?php echo $color;?></b>.
   </h2>
   </body>
   </html>


Explanation

1	Start the session for this page.
2	The session data is extracted from the $_SESSION[] array and assigned to variables.
3	The value of the constant SID is printed, the same values as in the previous page.
4	The session values are still available, all passed through the links. Because the value of the session ID is visible in the URL, it can easily be hijacked by someone else, which is not a secure situation.
5	The session data values are displayed in Figure 16.34.

Figure 16.34. Page 3: Passing session data to another page with a link. Output from Example 16.22

[View full size image]

16.4.10. Changing the Session ID

Using the URL to pass session IDs can lead to security problems, as they are plainly visible in the URL, bookmarkable, and accessible in HTTP_REFERER entries. To deal with the possibility of "leaking" the session ID, you should make sure that sessions are cleared frequently either by destroying them or by giving them a probable lifetime. (See the gc_probability directive in the php.ini file.)

Another technique is to change the session ID number with the session_regenerate_id() function. This function will change the ID number and leave the data intact so that if a session ID has been "hijacked," the data will no longer be available to the hijacker, but you will still have access to to it through the new session ID.

The only argument to this function is a boolean value, which determines whether or not to delete the old session file associated with the session ID being changed. The default is false.
Format

bool session_regenerate_id ( [bool delete_old_session] )


Example:

session_regenerate_id();
session_regenerate_id(TRUE);


Example 16.23.

   <?php
1      session_start();
2      $current_sessionid = session_id();
3      session_regenerate_id();
4      $new_session_id = session_id();
       echo "Session id was: $current_sessionid< br />";
       echo "Regenerated session id is: $new_session_id< br />";
   ?>


Explanation

1	A session is started. A session ID will be generated for this session if this is a new session.
2	The session_id() function returns the session ID number.
3	The session_regenerate_id() function will change the session ID number and leave the data intact that was associated with the session ID number just changed.
4	The new session ID is printed, as shown in Figure 16.35.

Figure 16.35. Regenerating a new session ID. Output from Example 16.23.

[View full size image]

16.4.11. Ending a Session

PHP really has no way to know when the user has left a session, so it provides several functions to help you control when to end a session. The following sections describe how to unset session variables and how to destroy the session files associated with them.
Deleting Session Variables

If you are sending the session ID via cookies, the cookie by default is deleted when the user closes his or her browser, but the session data still remains in the session file on the server. To destroy the session data, you can unset all the values in the $_SESSION array and then use the setcookie() function to remove the cookie by changing the expiration time of the cookie to an earlier date. Finally, you can force the session to end with the session_destroy() function, which deletes the session and the session file.

The PHP manual suggests that the nice way check for the existence of cookies is by simply calling print_r($_COOKIE).

Here are some examples:

// Unset a single session variable
unset($_SESSION['color']);

// Unset all of the session variables
$_SESSION = array();
// Delete the session cookie
if (isset($_COOKIE[session_name()])) {
   setcookie(session_name(), '', time() - 32000, '/');
}


The session_write_close() Function

If more than one script is using a session at any time, for example, two or three frames are loading one by one, PHP locks the session until each page has finished loading. This feature prevents two pages from writing out session data concurrently to the $_SESSION array and thereby corrupting the data. However, if the pages are primarily reading session data, then this locking feature can be worked around with the session_write_close() function. After the session data has been written, this function ends the current session and makes sure the session data is stored as soon as all changes have been made (see Example 16.26 at the end of this chapter). Normally, you will not need to use this function, as PHP takes care of storing session data and ending the session.
Format

void session_write_close ( void )


Example:

session_write_close();


The session_destroy() Function

The session_destroy() function deletes the session file and all of its data for the current session, but it does not unset a cookie or any global variables such as the $_COOKIE or $_SESSION arrays currently cached for the current session.
Format

bool session_destroy ( void )


Example:

session_destroy();


Example 16.24.

Code View: Scroll / Show All

   (Page 3)
   <?php
1      session_start();
2      extract($_SESSION);
       printf("%s",SID); // Print the session ID
       echo "The session id is " , session_id(), "< br />";
   ?>
   <html>
   <body bgcolor="<?= $color?>">
   <h2>
   Hi again <?= $user?>. You still like <b><?= $color ?></b>.
   <?php
       // Individually remove session variables
3      unset($_SESSION["user"]);
       unset($_SESSION["color"]);
4      //$_SESSION = array();   // Remove all session variables
5      session_destroy();
       exit();
   ?>
   </h2>
   </body>
   </html>

					  


Explanation

1	A session is started for this page that was called from another page where form information was gathered.
2	The session data is extracted and assigned to variables.
3	The unset() function removes individual session variables.
4	The array() function without arguments causes the $_SESSION array to be emptied. All session variables are removed.
5	The session_destroy() function removes the session and all its data.

Cleaning up Session Files and Garbage Collection

If you look in the directory or folder where your sessions are stored, you will see that the number of session files builds up quickly. Garbage collection is the process of cleaning up old sessions, a task left to PHP. If cookies are being used, the server does not know whether or not the cookie file still exists on the user's browser. Also, session files have a default lifetime of 24 minutes and then they will be cleaned up by the PHP garbage collector unless you extend their lifetime. The gc_maxlifetime configuration directive is used to determine how long PHP should wait (in seconds) before destroying a session based on how long the session has been idle since the last time was it was accessed.

For example:

$garbage_timeout = 3600; // 3600 seconds = 60 minutes = 1 hour
ini_set('session.gc_maxlifetime', $garbage_timeout);


The garbage collector does not just jump up and start removing files every time a session is invoked. It collects garbage based on a probability factor set in the session.gc_probability directive in the php.ini file. This directive specifies with what probability the files identified as garbage should be removed. If gc_probability is 100, the cleanup is performed on every request (i.e., with a probability of 100 percent); if it is 1, as it is by default, old sessions will be removed with a probability of 1 percent every time a session starts.

After setting these two configuration directives, the last bit of advice is to move the timed session files into their own directory. Otherwise, the garbage collector will not be able to differentiate between timeouts on a per-file basis.

For a complete and very readable explanation on PHP garbage collection, see http://www.captain.at/howto-php-sessions.php.
16.4.12. Session Runtime Configuration

PHP session management has many configuration options for us to choose from.
PHP Session Functions

PHP provides the functions shown in Table 16.4 to handle sessions, many of which we have covered in this chapter. Each of these functions is documented in the PHP manual at http://us3.php.net/session.

Table 16.4. PHP Session Functions
Function	Definition
session_cache_expire()	Returns the current setting of session.cache_expire, default 180 minutes.
session_cache_limiter()	Returns the name of the current cache limiter that defines the cache control HTTP headers sent to the client and what rules determine how the page content can be cached.
session_commit()	An alias for session_write_close().
session_decode()	Decodes the session data.
session_destroy()	Destroys all of the data associated with the current session, but does not unset any of the global variables associated with the session, or unset the session cookie.
session_encode()	Encodes the current session data as a string.
session_get_cookie_params()	Returns an array with the current session cookie information, including lifetime, path, domain, and secure.
session_id()	Returns the session ID for the current session.
session_is_registered()	Returns TRUE if there is a global variable if its name is registered in the current session.
session_module_name()	Returns the name of the current session module. If module is specified, that module will be used instead.
session_name()	Returns the name of the current session or if a name is specified, changes the name of the current session.
session_regenerate_id()	Replaces the current session ID with a new one, and keeps the current session date.
session_register()	Registers one or more global variables with the current session.
session_save_path()	Returns the path of the current directory used to save session data or sets a new path.
session_set_cookie_params()	Sets cookie parameters defined in the php.ini file. The effect of this function lasts only for the duration of the script.
session_set_save_handler()	Sets the user-level session storage functions that are used for storing and retrieving data associated with a session; for example, for file and database storage.
session_start()	Starts a session.
session_unregister()	Unregistered a global session variable.
session_unset()	Unsets all session data currently registered.
session_write_close()	Stores the session data and closes the session.

16.4.13. Implementing a Login System with Sessions

The following example consists of three separate files.

   1.

      The first file is a simple HTML form, the login page, where the user enters a username and password.
   2.

      The second file, the authentication page, is a PHP script that will verify the username and password, and establish a "logged in state" if the username and password are valid. This file will also be used for logging out the user. The action to log in depends on the parameter (login) provided by the POST method from the HTML form (hidden input element). The action to log out is performed after the user has logged on, been redirected to the third page with protected content, and clicks on the logout link.
   3.

      The third file is a PHP script that will show protected content only if the user is logged in. This file also describes a simple way to conditionally display a whole HTML block.

Sessions are used to remember users who are logged in and their password. In a real-world situation, you will probably use a database to store the username and password, and the protected content could be stored in a text file or database.
Example 16.25.

Code View: Scroll / Show All

   (Page 1)
   ##### begin #####
   ##### login.html #####
   <html>
   <head>
       <title>Simple login page</title>
   </head>
   <body>
       <p>
1          <a href="protected.php">Protected content</a>
       </p>
       <p> Type phpbee for both username and password </p>
2      <form action="auth.php" method="post">
           Username< br />
3          <input type="text" name="username">< br />
           Password< br />
4          <input type="password" name="password">< br />
5          <input type="hidden" name="login">< br />
           <input type="submit"> <input type="reset">
       </form>
    </body>
    </html>

    ##### login.html #####
    ##### end #####

					  


Explanation

1	This is a link to the protected page (page 3) where special content can be read only if the visitor has typed in a valid username and password.
2	After the form has been submitted, the PHP script (page 2), auth.php, will be executed. This page will determine whether or not the visitor is authorized to log in.
3	The visitor is asked to type in the username here. See Figures 16.36 and 16.37.
4	This is where the user types in the password.
5	To submit information that is not entered by the visitor, a hidden field is used and assigned the value "login".

Figure 16.36. Page 1: The login.html file.


Figure 16.37. Page 1: The visitor fills out the form.


Example 16.26.

Code View: Scroll / Show All

   (Page 2)
   ##### begin #####
   ##### auth.php #####

   <?php
1      session_start();
       // User is logging in
2      if (isset($_POST["login"])){
3         if (isset($_POST["username"]) && ($_POST["username"]
              == "phpbee")
          && isset($_POST["password"]) && ($_POST["password"]
            == "phpbee"){
4           $_SESSION["Authenticated"] = 1;
          }
          else{
5            $_SESSION["Authenticated"] = 0;
          }
6         session_write_close();
7         header("Location: protected.php");
       }
       // User is logging out
8      if (isset($_GET["logout"])){
9         session_destroy();
10        header("Location: login.html");
       }
    ?>

    ##### auth.php #####
    ##### end ####

					  


Explanation

1	The session for this page starts here for auth.php (page 2).
2	If the user has filled out the login form in login.html (page 1), then the $_POST["login"] variable will be set, and the statements in the if block will be executed.
3	If the username is set and has a value "phpbee", and the password is set and also has the value "phpbee", the statement in line 4 is executed.
4	The session variable is set to 1. The value of 1 will be used later to determine that the user is logged in.
5	If either a valid username or password were not entered, the session variable is set to 0. A value of 0 will be used to determine that the user is not logged in.
6	The session_write_close() function stores the session data now and closes the session.
7	The user is directed to protected.php (page 3). This is the page that is not accessible to anyone who is not logged in.
8	If the user entered the protected page and clicked the link to log out, the variable $_GET["logout"] will be set, and the statements in the if block will be executed.
9	The session and all its data are destroyed.
10	The user is redirected back to the login page. Because the session was destroyed, he or she is no longer authenticated to go to the protected page.

Example 16.27.

Code View: Scroll / Show All

   (Page 3)
   ##### begin #####
   ##### protected.php #####

   <?php
1      session_start();
   ?>
       <html><head><title>Protected page</title></head>
       <body>
   <?php
2      if (isset($_SESSION["Authenticated"])
          && ($_SESSION["Authenticated"] == 1)){
   ?>
3      <h2>Protected content</h2>
       <p>Hello. Since you are logged in, you can view protected content</p>
4      <p>You can also <a href="auth.php?logout">log out</a></p>
   <?php
       }
       else{
   ?>
       <h2>You are not logged in</h2>
       <p>Hello. Since you are not logged in, you cannot view protected content</p>
5      <p>But you can <a href="login.html">log in</a></p>
   <?php
       }
   ?>
   </body>
   </html>

   ##### protected.php #####
   ##### end #####

					  


Explanation

1	The session starts for page 3. See Figure 16.38.
2	If, on page 2, the session variables were set and $SESSION["Authenticated"] was set to 1, the visitor is logged in and will be able to read whatever is on line 3.
3	This is where the content would be added for this page, the content only viewable if the user successfully logged in.
4	This link will send the user back to page 2, auth.php. The word logout appended to the question mark, will be passed via the GET method and assigned to the $_GET[] array.
5	This link returns the visitor back to the login page, page 1.

Figure 16.38. Page 3: The visitor is logged in.

16.5. Chapter Summary

In this chapter we discussed how PHP uses cookies and sessions to maintain state; that is, save information between different accesses to a Web page, allowing you to customize your applications based on user preferences, manage logging in and out of your site, use links and hidden fields to pass session information back and forth, and so on.

What are the pros and cons of cookies versus sessions and vice versa? The cookie stores the visitor information on the user's computer even if a session has ended. The the lifetime of a cookie can be a long period of time or it can end when the user closes his or her browser. A user can go to a Web site, browse around and come back, even log out and the cookie can persist on his or her hard drive, keeping track of the user's preferences, shopping cart information, number of times he or she visited the site, and so on. But if the cookie has important information such as a password or user ID, it is easy to read that information unless it is encrypted, and some people feel that cookies are a security threat because they are passed back and forth across the network and are stored in a text-based readable files. Because a user can disable cookies for his or her particular browser, you have no guarantee that they are being accepted.

PHP sessions are safer because they do not send any sensitive data over the network. They store the user information in variables on the server. As you have seen in this chapter, even sessions rely on cookies because the session ID is encrypted and normally passed in a cookie, but there are alternative ways to handle users who have disabled cookies for their browser, such as passing the data in hidden form fields or URLs. Although this is considered insecure, you can regenerate the session ID after using it or destroy all the session variables. The lifespan of sessions is normally the length of a session, and after 24 minutes, the session files are deleted, but this can also be controlled in the php.ini file. What if you have a cluster of servers? How will the session files be managed? At least with a cookie, only one browser is necessary, no matter how many servers are involved. Which is best?

It has been said that over 90 percent of sessions use cookies, so perhaps a symbiotic relationship between the two is a reasonable approach. Ultimately, you must weigh the pros and cons and decide what works best for you. (See http://www.thescripts.com/forum/thread433783.html for further discussion.)
16.5.1. What You Should Know

Now that you have finished this chapter you should be able to answer the following questions:

1.	What is meant by stateless?
2.	What are cookies used for and where do they reside?
3.	What is the life span of a cookie?
4.	How are cookies sent from the server to the browser?
5.	How does PHP store cookies?
6.	What is serialization?
7.	What is the advantage of using PHP sessions?
8.	What is meant by a cookie-based session?
9.	What is a session ID number and where is it stored?
10.	What are the PHP buffering functions?
11.	How are sessions registered?
	
12.	How are sessions deleted?
13.	What is the purpose of the PHP session_write_close() function?
14.	What is garbage collection?
15.	What are the disadvantages of using cookies? What are the disadvantages of using sessions?
16.5.2. What's Next?

The next and last chapter introduces object-oriented programming with PHP. You will learn how to create classes to encapsulate data and functions. You will create instances of a class, called objects, and assign properties to describe the object. You will design methods, special functions, to manipulate the object and learn how to keep the object's data protected from outside access. You will see how one class inherits from another.

Chapter 16 Lab

1.	Create a login page that asks the user for a username and password. Trim the username and password to remove any unwanted whitespace. The action attribute of the from will redirect you to a new page, called verify.php.
2.	The verify.php page will start a session and check that the username and password fields are not empty and also that they are correct. If not, the user will be informed, and redirected back to the login page. If correct, the user will be directed to your home page (you may want to use the database form from the last exercise).
3.	When the user is ready to log out, end the session.
4.	Create a drop-down menu that allows the user to select from a list of vacation spots. Save his choices in a cookie.
5.	Link to another page that will print images of the vacation spots that the user selected.
6.	When the user returns to the menu, he or she will see the list selected the last time he or she was on this page.


