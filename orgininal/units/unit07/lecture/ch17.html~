Chapter 17. Objects

17.1. What Are Objects?

Objects are things we deal with every day. PHP deals with objects, as do most programming languages, and these languages are called object-oriented programming (OOP). OOP is a way of trying to solve a problem in terms of real-world objects. Some people are apprehensive at the thought of tackling this kind of programming, and are perfectly happy to stick with top-down, procedural programs. Just as the everyday objects we use are not switchblades and hacksaws, neither are programming objects. They are just a way of representing data.

As PHP has evolved from a tool for building simple home pages to a language for serious Web development, so has its support for OOP. Once programs start to get larger and more complex, planning and design become more important. Think of a simple home page put together with some family photos, links, and blogs. Then think of a Web site like Amazon or eBay where there are thousands of forms, links, and transactions taking place all the time, all over the world—the thought of putting something like that together is staggering. OOP is best suited to manage the complexity of such large Web sites. Even if you do not program using objects, if you are reading and using PHP programs written by other programmers, you are bound to run into this style of programming. This chapter gently introduces you to PHP objects and some of the features that have been added to the language in PHP 5.

When talking about PHP data types in Chapter 4, "The Building Blocks," we discussed two types: primitive types and composite types. Like arrays, objects are composite types. They provide a way to organize a collection of data into a single unit. Object-oriented languages, such as C++ and Java, bundle up data into a variable and call it an object. So does PHP. Each object-oriented language you encounter is based on the same principles, but often the terminology is not exactly the same when describing the concepts. You could say that PHP is like Java and C++, but has its own way of dealing with objects.

When you learn about objects, they are usually compared to real-world things, like a black cat, a modern painting, or a green pillow. Using the English language to describe an object, the object itself would be like a noun: a person, place, or thing.

Nouns are described with adjectives. For the cat it might be described as fat and furry with green eyes, four legs, and a tail; the painting is a British frigate, oil on canvas, and sells for $52,000; and the pillow is green silk, square, with dimensions of 18" x 18". The adjectives that collectively describe these objects are called the properties (or attributes) of the object. The object is made up of a collection of these properties.

In English, verbs are used to describe what the object can do or what can be done to it. The cat eats and sleeps, and its tail twitches; the painting can be framed, sold, or purchased; the pillow's dimensions can be increased or decreased, its fabric and color changed, and so on. These verbs are functions called methods in object-oriented languages.
17.1.1. Objects and Classes

Objects are defined in a class. A class is a template or a blueprint that defines what an object should look like and what it can do. A class represents a group of similar objects, such as a class of employees, a class of hotels, or a class of cars. The object in a class is a concrete person, place, or thing. Like a cookie cutter, a class gives an object its form, and as with a cookie cutter, you can build many objects of the same class. The employee object might be described to have a name, address, and phone number. Although the object can later change its values, it still belongs to the same class. You can change Bob's phone number, but he is still in the employee class. You can change the color of the car, but it is still in the car class.

A class contains a collection of variables (properties) and functions (methods). Like a blueprint, by itself the class does nothing. It defines an object and its properties and methods. Properties describe the object. Methods are functions that determine the behavior of the object; that is, what kind of actions can be performed on or by the object. As you can see in Figure 17.1, a class is a unit consisting of a name for the class, in this case House, the variables that describe the house, and the methods that describe the behaviors of the object, or what it can do. A class is an aggregate or composite data type. Like an array that contains a collection of key–value pairs, the class represents a collection of properties and methods.

Figure 17.1. A House class.

17.2. Working with Classes
17.2.1. Defining the Class

To create a class you use the class keyword followed by the name of the class. The class definition, like a function definition, is enclosed in a set of curly braces. The name of a class follows the same naming conventions as normal variables (minus the dollar sign) and the class name, by convention, starts with a capital letter. For example:

<?php
   class House
   {
      <definition goes here>
   }
?>


The class House might have variables (called attributes) such as $owner, $address, $color, or $number_of_rooms, as well as functions (called methods), such a showHouse(), cleanHouse(), or paintHouse(), for example.

Once the class is defined, it is used to create specific objects. Just as when you design a blueprint for a house, the real house does not yet exist. You must build it from the blueprint. The class is analogous to the blueprint and the object to the actual house. We could build many houses from the same blueprint and we can build many objects from a class. Just as a house is located at an address, each object has its own memory address. PHP provides the address and cleans up the memory when the object is no longer needed, when the program ends.

Once we have the basic stuff of which houses are made, we can extend the blueprint to add new features to the house, such as a new family room or a fireplace. Classes can also be extended to create more refined objects. Extending a class is called inheritance. Inheritance allows the programmer to create a new class without writing a brand new one. He or she can reuse an existing class and add some new features and functionality. Inheritance is one of the benefits of OOP that we discuss later in this chapter.
17.2.2. Instantiating the Class

Once the class is declared, the object needs to be created. In the real world you would build a new house; in the object-oriented world, you would instantiate a new House class or create a new instance of the House class. To make a new object, we use the reserved keyword new. To reference the object, we use the special variable called $this. Each instance of a class has the same property, but different copies, so that the values can be different; for example, if you have two house objects of the same class, and each house object has a property called $owner, the values assigned to $owner can differ from house object to house object, just like in the real world.
What's "new"?

The difference between an object and a class is that a class is conceptual and an object is real. The object is the actual variable that you manipulate. You can assign and retrieve its values, pass it to functions, delete it, copy it, and so forth. It holds a specific set of data. The new keyword is used to create a PHP object that is an "instance" of a class.

$myhouse = new House;


The new keyword causes PHP to look for a class named House, create a new copy, and assign it to the variable $myhouse. A new House object has been instantiated, which is like saying "We just built a new house and called it $myhouse," and to make another object from the House blueprint, you could say:

$yourhouse = new House;


Now we have two instances of the House class, two house objects, $myhouse and $yourhouse (see Figure 17.2).

Figure 17.2. Instantiating the House class.

[View full size image]

The Properties and Methods

Properties (variables) and methods (functions) together are called class "members." The properties of a class are defined as variables. Before PHP 5, the keyword var was used to define a public property of the class; that is, a property variable that is visible throughout the current PHP script. The var keyword has been deprecated as of PHP 5; you now declare public properties with the public keyword. Methods (class functions) default to public so you do not need to specify them as public:

(PHP 4)

var $owner = "John Doe:;
var $address;


(PHP 5)

$owner = "John Doe";  // Default is public
public $address;


You can assign initial values to the variables, but they must be string or numeric constants, not expressions like 5*6. New properties can be added at any time.

A method is a function defined within the class. It describes the behaviors of the class. It looks like any other function in structure:

function showHouse(){
   < statements go here>
}


The one major difference between methods and ordinary PHP functions is the $this keyword used to reference the current object, and in the way the methods are invoked.
What's $this?

When a class is defined, the object is created later, making it impossible for the class writer to know what the user of the class will name his or her objects. To reference an object, PHP provides a pseudo-variable, called $this, which references the current object. If the class built the two house objects as shown in the last section, then it would be able to keep track of which house was being used, because $this always references the current object. For example, if myhouse is the current object, then all the properties and methods of the class apply to myhouse. If the class has defined a cleanHouse() method for each house object, $this references the house object currently being used and $this>cleanHouse() applies to that object. In real-world terms, when I am in my house, I am not going to be cleaning your house. Notice that each property is preceded with the $this variable and an arrow operator. If you have many house objects, then $this will keep track of which house you are currently using, both its properties and methods.

function cleanHouse(){
   echo $this->owner;
   echo $this->address;
}


As we go further on, you will see how useful $this is.
The -> Operator

After a class has been defined, it can be instantiated; that is, we create objects of that class. As you will see next, to assign properties and call methods, an arrow operator is used to get or set the value of the property; for example, if an object called $myhouse is created, to assign a value for the address property, the statement might look like this:

$myhouse->address="14 Main St.";


To call the method showHouse(), it might look like this:

$myhouse->showHouse();


The name of the object precedes the arrow and the property or method so that PHP knows to which object the property and method apply.

Figure 17.3. A House class and creating a house object and accessing it.

[View full size image]

The gettype() and get_class() Functions

PHP provides a number of built-in functions that return information about classes and objects. Table 17.1 gives you a complete list. Two functions that will be helpful as you start learning about objects are the gettype() and the get_class() functions. As you might remember (see Chapter 4, "The Building Blocks") from when we discussed data types, the gettype() function takes a variable as its argument and returns its data type, such as string, boolean, array, and so on. It will return "object" if the argument represents an object that was created using the new keyword. The get_class() function will tell you the name of the class from which the object was created.

Table 17.1. PHP Built-In Class Functions
Function	What It Does	Example
get_class()	Returns the name of the class of an object.	string get_class([object obj])
get_class_vars()	Returns an associative array of public properties.	arrayget_class_vars(string class_name)
get_declared_classes()	Returns an array of classes defined in the current script.	array get_declared_classes(void)
get_object_vars()	Returns an array of properties for an object.	array get_object_vars(object obj)
get_parent_class()	Returns the name of the parent class for the class or object.	string get_parent_class([mixed obj])
gettype()	Returns the data type of a variable; if an object is given, returns "object."	string gettype(mixed var)
instanceof (PHP 5)	A type operator that has replaced is_a().	instanceof classname
interface_exists()	Returns true if an interface has been defined.	bool interface_exists(string interface_name [, bool autoload])
is_a()	Returns true if the object is of this class or this class is its parent.	bool is_a(object object, string class_name)
is_subclass_of()	Returns true if object has this class as one of its parents.	bool is_subclass_of(mixed object, string class_name)
method_exists()	Returns true if this method exists.	bool method_exists(object object, string method_name)
property_exists()	Returns true if property exists in the class and is accessible.	bool property_exists(mixed class, string property)

Example 17.1.

   <?php
   # PHP5 Simple class
1  class House{   // Declare a class
2     public $owner=" John";  // Create class variables/properties
      public $address="Anywhere, USA";
3     function displayHouse(){
4         echo "This house if of type ", gettype($this),".<br>\n";
5         echo "It belongs to the ", get_class($this),
               " class.<br>\n";
6         echo "This house is owned by $this->owner. ";
          echo "It's address is $this->address.\n<br>";
      }
   }
   // Using the class
7      $myHouse= new House();  // Create an ojbect
8      $myHouse->displayHouse();
   ?>


Explanation

1	A House class is declared.
2	The variables for the House class, called properties, are $owner and $address. Both properties have been assigned inital string values.
3	A function for the House class is declared. Functions within classes are called methods.
4	The gettype() built-in function returns the data type of $this. Because $this represents the current object, the type returned is "object." See the output in Figure 17.4.
5	The get_class() function returns the name of the class to which the object represented by $this belongs.
6	The value of the object's property $owner is displayed.
7	A new object is created with its own properties defined in the class.
8	After creating the new object, the displayHouse() method displays its properties.

Figure 17.4. A simple class.


17.2.3. Creating a Complete Class

Now that we have defined some of the pieces involved in creating a class, we will build one from scratch. The following example defines an Employee class and then creates some objects of that class. To see a diagram of the class, see Figure 17.5.

Figure 17.5. The Employee class and how it is used.

[View full size image]

Example 17.2.

Code View: Scroll / Show All

    <?php
    // Defining the Class
1   class Employee {  // Define the class

2      public $name;        // The properties/attributes
3      public $address;
4      public $phone;

5      function printPersonInfo()  // The methods
       {
           echo "<hr><b>Employee Info</b><br>";
           echo $this->name . "<br>\n";
           echo $this->address . "<br>\n";
           echo $this->phone . "<br>\n";
       }
    }
    // User of the class
6   $Heidi = new Employee();     // Create a new object
7   $Heidi->name = "Heidi Clum"; // Assign properties
8   $Heidi->address = "1234 Somewhere Blvd ";
9   $Heidi->phone = "123-456-7890";

10  $Brad = new Employee();     // Create another object
11  $Brad->name = "Brad Bit";
12  $Brad->address = "4321 Sunset Blvd ";
13  $Brad->phone = "987-654-3210";

14  $Heidi->printPersonInfo();   // Access the object with the method
15  $Brad->printPersonInfo();

    ?>

					  


Explanation

1	A class called Employee is declared. The class definition is enclosed within curly braces.
2–4	The variables, called properties, belonging to this class are defined. These properties are declared public meaning they are visible throughout your script. The var keyword is used for backward compatibility with PHP 4, but both public and var are now acceptable.
5	This is a function, called a method, defined for the class.
6	A new object is created for the class Employee and assigned to a variable called $Heidi. The $Heidi object is allocated its own copies of the properties defined within the Employee class.
7–9	To assign values to the properties of the object, the object is followed by an arrow and the property name. $Heidi is an object of class Employee and thus has variables name, address, and phone.
10	We declare another object of type Employee and this time assign it to variable $Brad. Although $Heidi and $Brad are both of class Employee, they have different values for the properties name, address, and phone.
11–13	Values are assigned to the properties of object $Brad.
14	The method, printPersonInfo(), applies to the object, $Heidi. The object is the noun, the method is the verb. It is the action that is taking place on the object. The method is called by appending the object with the arrow operator and the name of the method. By doing this PHP knows which object in the class this method applies to. The method's function is to print out the properties for the current object, in this case $Heidi. Because it is accessing the data for the object, an instance of the class, the method is called an "access" method or an "instance" method.
15	Similarly, for the object $Brad, the printPersonInfo() method is called and it will print values specific to the $Brad object.

17.2.4. Displaying an Object

In Chapter 8, "Arrays," we used the PHP built-in function print_r() to see the contents of an array. Now you can use it to view the contents of an object. In the previous example the output of print_r() would be:

Employee Object
(
   [name] => Heidi Clum
   [address] => 1234 Somewhere Blvd
   [phone] => 123-456-7890
)
Employee Object
(
   [name] => Brad Bit
   [address] => 4321 Sunset Blvd
   [phone] => 987-654-3210
)


17.2.5. Functions for Getting Class Information

PHP provides a set of built-in functions that will return information about your class and its objects. Table 17.1 provides a list of these functions. For a complete list and examples of how these methods are used, see http://us3.php.net/manual/en/ref.classobj.php.
17.2.6. Encapsulation and Information Hiding

Encapsulation and information hiding are closely related terms you will hear often in the object-oriented world. We use encapsulation when combining the properties and methods to make a class. By encapsulating the data in the class, the details of the class can be hidden from the user. When we created ordinary functions, the instructions were encapsulated within the function definition. When you call a function, you do not know all the details of how it works, you just need to know how to call it, what arguments to pass, and what it returns. When you create an object, you must know how to use its methods to access it. The details of the object are encapsulated within the class.

Information hiding is obscuring the details of the class from the user. In the previous example, the Employee class gave Heidi her own name, phone, and address. However, Heidi's information was "public" in scope. It could be directly accessed from outside the class. The user of the class could change Heidi's address and phone number. What if you do not want anyone to change Heidi's address or phone number? Often you have objects in which you do not want to allow direct access to the object's variables. For example, a bank account object might have a variable representing the account balance. This data should not be available to anyone outside the class, and to access it, the user should use methods provided specifically for that purpose. Methods such as makeDeposit(), makeWithdrawal(), and getBalance() should be the only way to manipulate the account balance, similar in the real world to using an ATM machine. In the object-oriented world, you will often hear the phrase, "Access private data with public functions."

Key principles of OOP are encapsulation and information hiding; that is, combining methods and properties into a class and keeping the class variables hidden from direct access by the class user. Data hiding helps to protect the object's data from being corrupted, and if the class implementation is modified, this should not affect the way the class is used; just as when you have the oil changed in your car, you do not change the way you see the car or how you drive it.
17.2.7. Class Members and Scope

The term members refers to the properties and methods of a class, and the term scope refers to where the members can be accessed within the program. Properties and methods are prefaced with a scope descriptor, such as public, private, or protected. If a member is not prefaced by a scope descriptor, it is considered to be public. You should always specify a scope descriptor for properties.
Public Scope

Public scope is the default scope for all properties and methods of an object. Public means that class members can be accessed from everywhere in the script and are not restricted to the class. In Example 17.2 the name, address, and phone properties were public. From anywhere within the script, the value of those properties could be changed. As stated earlier in this chapter, prior to PHP 5, the descriptor was var; now you would use public. Methods themselves do not require the descriptor and are public by default.
Private Scope

Private members are visible or accessible only in the class that defines them. They are not directly accessible outside the class or to subclasses (classes derived from the current class; see "Inheritance" on page 763). If you create private variables, then public methods are used to manipulate the data. In the following example, the three variables of the Employee class are declared private. It is not possible for some part of the program outside the class to change or manipulate the values of these variables—a good thing. In Example 17.2 if the properties had been declared private, the only way that the object's properties could have been changed would be through its methods.

class Employee{
   private $name;
   private $phone;
   private $address;
}


The methods used to manipulate this data would be publicly available.
Protected Scope

If you create a new class from an existing class, the private members will not be available to the new class. Protected members are available to the class where they are created and to any subclasses (see "Inheritance" on page 763).
Example Using Private Scope

The following example includes a BankAccount class. The only property is the balance that is marked private. The only way this balance can be changed from a user from outside the class is through its public methods. This example hides the balance from the user. The properties and methods are encapsulated within the BankAccount class.
Example 17.3.

Code View: Scroll / Show All

   <?php

1  class BankAccount {

2     private $balance=0;

      function makeDeposit( $amount ) {
3        $this->balance += $amount;   // Add to the current balance
4        echo '<br>Deposited: $' . number_format( $amount, 2);
      }
      function makeWithdrawal( $amount ) {
          // Subtract from the current balance
5         $this->balance -= $amount;
6         echo '<br>Withdrew: $' . number_format( $amount, 2);
      }

      function getBalance() {
7         echo '<br>Current Balance: $' . number_format(
             $this->balance, 2);
      }
   }

8  $myAccount = new BankAccount();
9  $myAccount->makeDeposit( 100.00 );
10 $myAccount->makeWithdrawal( 40.00 );
11 $myAccount->getBalance();

   ?>

					  


Explanation

1	A class called BankAccount is defined.
2	This class has only one variable, $balance, initially set to zero. The keyword private tells PHP that this variable can be accessed only from within the class and not from outside. Thus, $myAccount->balance=100000 will fail if that statement is issued from outside the class.
3	The only way to alter the balance is through the class methods. Method makeDeposit() will add the $amount to $this->balance. Remember, the pseudo-variable $this refers to the object currently being used.
4	This line prints the amout that was deposited. (The function number_format() is used to format the dollars with two decimal spaces.)
5–6	Similarly, the function makeWithdrawal() will deduct $amount from $this-> balance.
7	The getBalance() method returns the value of the current balance. Although the user can view the balance, he or she does not have access to it and cannot change it directly.
8	A new object called $myAccount is created.
9	The makeDeposit() method is called and adds $100 to the account object, $myaccount.
10	The makeWithdrawal() method withdraws $40 from the account object, $ myaccount.
11	A call to getBalance() for the object $myAccount will print the balance of $60, the correct amount. The output is shown in Figure 17.6.

Figure 17.6. The BankAccount class contains a private variable to hold the balance, accessed only by public methods to deposit, withdraw, and get the balance. Output from Example 17.3.


17.2.8. Magic Methods

PHP provides special methods that are invoked automatically based on what the program is doing—creating an object, setting a property value, retrieving a value, or destroying an object. A constructor is a magic method that is invoked when you call new to create a new object, a get or set method is invoked when you access the object, and a destructor method is invoked when your program ends. These special methods have names starting with two underscores: __construct(), __destruct(), __set(), and __get(). We discuss each of the "magic" methods in the following sections. (See the PHP manual for a complete list of magic methods.)
Constructors

A constructor, as the term implies, is a builder or creator. When you assign values to properties in a class, PHP will automatically build or construct a new object when new is called by the user of the class. When we created a new house, new employee, and new bank account, we did not explicitly call a constructor. We let PHP create the object and assign the properties to it. If you want to customize the initialization of an object, PHP lets you define a constructor method of your own. Once the object has been created with new, PHP will check to see if you have defined a constructor, and if so, it will automatically be called. This magic method is called right after new has created the object. For example, to set the initial bank account balance to zero for a new bank account, a constructor could be defined to perform this initial task.

Although functionally the same, PHP 4 and PHP 5 use a different syntax for creating constructor methods. PHP 4 constructor methods are named with the same name as the class. So, if you have a class named MyClass, the constructor is a function named MyClass.

PHP 5 provides the constructor, a magic method called __construct(). This method is not normally called directly by the user, but is automatically invoked when the new keyword is used. PHP 5 is backward compatible, so if a function named __construct() is missing in the class declaration, the old-style constructor will be used if there is one; if neither are declared, then PHP creates the object and assigns it values provided in the class, just as demonstrated in all of the examples thus far.
Format

PHP 4 Format: void class_name([mixed args[, ...])

Example:

function MyClass(){
   $this->balance = 0;
}


PHP 5 Format: void __construct ( [mixed args [, ...]] )

Example:

function __construct() {
   $this->balance = 0;
}


Example 17.4.

   <?php
   # PHP 5
1  class House{
2      function __construct(){   // Constructor
           print "Constructor initializing a new house.\n";
       }
     } /* End class definition */

3       $my_house= new House;
4       $your_house=new House;
     ?>


Explanation

1	A House class is defined.
2	The __construct method acts as a class constructor and is called when the object is being created (PHP 5).
3	The new keyword is used to create a House object. The "magic" function on line 2 is automatically invoked at this time.
4	Another House object is created, causing the __construct() function to be invoked again. See Figure 17.7 (left).

Figure 17.7. (left) Using the PHP 5 "magic" constructor method; (right) Using a constructor method named after the class. Output from Examples 17.4 and 17.5.

[View full size image]

Example 17.5.

   <?php
   # PHP 4
1  class House{
2      function House(){    // Constructor PHP 4
           print "Constructor initializing a new house.\n";
       }
   }   /* End class definition */

3       $my_house= new House;  // Create object
4       $your_house=new House;
     ?>


Explanation

1	A House class is defined.
2	When the function has the same name as the class, it is a constructor and will be invoked when a new House object is created.
3, 4	Two new House objects are created with the new keyword. The constructor on line 2, named after the class, is automatically invoked at this time. Prior to PHP 5, this was the only way to create a constructor method.

Example 17.6.

Code View: Scroll / Show All

   <?php
   # PHP 5
1  class House{

2     private $owner;
3     public $address;

4     function __construct($owner, $address){
         if (! empty($owner)&& ! empty($address)){
5           $this->owner=$owner;
            $this->address=$address; 6
            print "Constructor initializing a new house.\n";
         }
      }

7     function displayHouse(){
         echo "This house is owned by $this->owner. ";
         echo "It's address is $this->address.\n<br>";
      }
   }

      // Using the class to create objects
8     $myHouse= new House("Joe","13 River Road");
9     $yourHouse = new House("Brad","1 Roundabout Drive");
10    $myHouse->displayHouse();
      $yourHouse->displayHouse();
   ?>

					  


Explanation

1	The House class is declared.
2	The $owner property is declared private. It cannot be directly accessed from outside the class. In this example, declaring this variable private is not really necessary; it is done just to illustrate the scope designator.
3	The $address property is publicly available throughout the script.
4	PHP's constructor is defined here. A class automatically calls this method for each new object that is created. The constructor method accepts arguments of varied types and number.
5	This is where the initial values are being set for the new object.
6	Each time the contstructor is called, that is, each time a new House object is created, this line is printed, as shown in Figure 17.8.
7	The class method displayHouse() is a getter method. It retrieves and displays the properties for the object that called it.
8	A new House object is created with new. Two arguments are passed to the constructor of the class, the name Joe, and the address 13 River Road. The constructor is called automatically and will assign these values to the object's properties. This instance is called $myHouse.
9	Another House object is created. The constructor will automatically be called for this object and assign values to its properties. We now have two house objects in the program's memory, both at different memory addresses and both with their own properties.
10	To display the properties of the objects, each object calls displayHouse(), a user-defined function that retrieves and prints the properties of the object that is named on the left side of the -> operator. See Figure 17.8.

Figure 17.8. Calling the constructor in PHP 5. Output from Example 17.6.

[View full size image]

Destructors

A destructor, as the name implies, is used to destroy an object. A destructor method is called right before the object is released. Releasing an object means that all references to the object have been unset or the object has gone out of scope. The destructor would be used to perform any final actions you want to perform such as deleting old files, releasing resources, and so on. Typically, PHP releases the objects at the end of each script.

Being able to use a destructor is a PHP 5 feature. PHP 4 does not have destructors at all. In PHP 4 you created a function that simulated a destructor or you could use the PHP unset() function to force the removal of an object, but PHP 5 provides a specific destructor function named __destruct(). This method takes no parameters, and it cannot be called directly. It will be called implicitly when you release your object.
Format

void __destruct ( void )


Example:

function _ _destruct();


Example 17.7.

Code View: Scroll / Show All

   # PHP 5
   <?php
1  class House{

   private $owner;
   public $address;

       function __construct($owner, $address){
          if (! empty($owner) && ! empty($address)){
             $this->owner=$owner;
             $this->address=$address;
             echo "Constructor initializing a new house ";
             echo "in the ", get_class($this)," class.\n";
          }
       }
       function displayHouse(){
           echo "This house is owned by $this->owner. ";
           echo "Its address is $this->address.\n<br>";
       }
2      function __destruct(){
          echo "Evacuate now! $this being destroyed\n";
       }
   }
       // Using the class to create objects
3      $myHouse= new House("Joe","13 River Road");
       $yourHouse = new House("Brad","1 Roundabout Drive");
4      $myHouse->displayHouse();
        $yourHouse->displayHouse();
   ?>

					  


Explanation

1	This is the same House class defined in the previous example.
2	The magic __destruct() method will be invoked just before the object is about to be destroyed; that is, if it is unset or the program is finished. The value of $this is an object with an ID of #1 for the first house, and an ID of #2 for the second house. The objects are destroyed in the order in which they were constructed. (The object ID numbers are created in the order the object is created, but there are some cases where this seems to be inconsistent. See http://devzone.zend.com/node/view/id/168.)
3	The user of the class creates two objects.
4	The displayHouse() method prints the properties of both houses. All output for this example is shown in Figure 17.9.

Figure 17.9. The destructor method. Output from Example 17.7.


Accessor Methods—Setters and Getters

You do not have access to a real house or bank account until it has been created. Likewise you cannot access an object until you have created it, and then you can manipulate it, give it values, extract values, and so on. Functions that give you access to an object are called accessor or instance methods, often termed setters and getters. A setter is a method used to assign a value to a class variable, and a getter is a method used to retrieve the value of a class variable. Simply said, "Put something in, set it; take something out, get it."
PHP's Setter and Getter Access Methods

PHP provides two magic methods, __set and __get, to protect public variables from direct access outside a class. These special functions are called automatically whenever the user tries to access an object's property either by assigning (setting) a value to it or by retrieving (getting) a value. The __set method takes exactly two arguments, the object's property variable and the value being assigned to it. The __get method takes one argument, the property of the object. These functions do not work with private variables and each function can only be defined once within the class.

Let's look at an example to see how this works.
Example 17.8.

Code View: Scroll / Show All

   <?php
   // The class
1  class Employee {
2     public $name;   // Properties
      public $address;
      public $phone;
   // Public magic methods
3      function __set($property,$value)   // setter
       {
4          $this->property = $value;
       }
5      function __get($property)     // getter
       {
6          return $this->property;
       }
   };

       // User of the class
7      $Heidi = new Employee();
8      $Heidi->name="Heidi Clum";
9      echo $Heidi->name, "\n<br>";
       $Heidi->address="1234 Somewhere Blvd ";
       echo $Heidi->address, "\n<br>";
       $Heidi->phone="123-456-7890";
       echo $Heidi->phone,"\n<br>";
       echo "<hr>";
       $Brad = new Employee();
       $Brad->name="Brad Bit";
       echo $Brad->name, "\n<br>";
       $Brad->address="4321 Sunset Blvd ";
       echo $Brad->address, "\n<br>";
       $Brad->phone="987-654-3210";
       echo $Brad->phone, "\n<br>";
   ?>

					  


Explanation

1	The Employee class is declared.
2	The Employee class consists of three public properties, $name, $phone, and $ address.
3	This magic method called __set takes two parameters: one to represent the incoming class property for the object, in this example called $property; and the second to represent the value that will be assigned to that property. When the user of the class makes a statement such as $Heidi->phone="123-456-7890", PHP automatically invokes this __set method and assigns properties to the current object, referenced by the pseudo variable, $this.
4	This is where a value (in this example, a phone number) is assigned to the $Heidi object.
5	The magic method called __get takes one parameter to represent the incoming class property, in this example called $property. Its purpose is to automatically retrieve the value of the object's property when the user of the class makes a statement such as echo $Heidi->phone;. See Figure 17.10.
6	The object's property value is retrieved and returned by the __get method.
7	A new instance of the Employee class is created, an object named $Heidi.
8	When this line is executed, PHP automatically calls the magic __set method to assign a value to the object.
9	When the value of the object's property is retrieved, the __get method is automatically called.

Figure 17.10. The magic __set and __get methods. Output from Example 17.8.


User-Defined Setters and Getters

When you design a class, you are not required to use PHP's built-in methods; you can write your own customized getters and setters. The properties can be declared as private and the only way they can be accessed is through the public setter and getter methods provided by the class, just another way to implement data hiding. The disadvantage of having a setter and getter for every property is that the program grows larger very quickly and thus more unwieldy and harder to maintain.

Example 17.9.

Code View: Scroll / Show All

   <?php
   // The class
   class Employee {
       // private variables
1      private $name;
2      private $address;
3      private $phone;
       // public methods
4      function setName($name)  // setter
       {
           $this->name = $name;
       }
5      function getName()   // getter
       {
           return $this->name;
       }
6      function setAddress($address)
       {
           $this->address = $address;
       }
7      function getAddress()
       {
           return $this->address;
       }

8      function setPhone($phone)
       {
           $this->phone = $phone;
       }

9      function getPhone()
       {
           return $this->phone;
       }

10     function printPersonInfo()
       {
           echo "<hr><b>Employee Info</b><br>";
           echo $this->name . "<br>\n";
           echo $this->address . "<br>\n";
           echo $this->phone . "<br>\n";
       }
   };
       // User of the class
11     $Heidi = new Employee();
12     $Heidi->setName("Heidi Clum");
       $Heidi->setAddress("1234 Somewhere Blvd ");
       $Heidi->setPhone("123-456-7890");
13     $Brad = new Employee();
14     $Brad->setName("Brad Bit");
       $Brad->setAddress("4321 Sunset Blvd ");
       $Brad->setPhone("987-654-3210");

15     $Heidi->printPersonInfo();
16     $Brad->printPersonInfo();
   ?>

					  


Explanation

1–3	The class variables are declared as private.
4	This is a setter method for the $name property of the class. This method is the only way the name can be updated from outside the class. In this implementation, the method simply assigns a new value to class property $name.
5	This is the getter method for the $name property. It simply returns its value.
6–7	These are the setter and getter methods for the address property.
8–9	These are the setter and getter methods for the $phone property.
10	The method getPersonInfo() displays all of the properties for the two objects. Because the method is part of the class, it has access to the private properties. This method does not attempt to change the object's properties; it simply displays them.
11	A new instance of the Employee class is created, an object called $Heidi.
12	The next three statements illustrate how the setter and getter methods are called for setting and retrieving the object's properties.
13	Another instance of the Employee class is created, an object called $Brad.
14–16	The setter and getter methods are now applied to the $Brad object. See Figure 17.11 for the output.

Figure 17.11. User-defined setters and getters. Output from Example 17.9.


17.2.9. Inheritance

The son inherited his father's title and estate. PHP classes can also inherit from a parent class. Inheritance is a mechanism of extending an existing class. By inheriting a class, we create a new class with all the functionality of an existing class, plus we can add new variables and methods to the new class. In this way, the existing class can be extended without modifying its code.

When one class inherits from another, the inherited class is called a subclass or a child. The class from which the subclass inherits is called the parent class, the super class, or the base class. A subclass is said to be derived from a parent class. In our examples we use terms subclass or child and parent class. Figure 17.12 shows a simple diagram of the parent–child relationship, each circle representing a class.

Figure 17.12. The parent–child class relationship.


Inheritance requires that at least one class already exists. This class will be the parent class. A new subclass is declared by using the keyword extends. In the following example, the Person class contains properties for a generic person: a name, an address, and a phone number. Later we design a more specific type of person, a person who is employed. However, because employed people are still "persons" we can create another class called EmployedPerson that will inherit all the functionality of the Person class and then extend that functionality by adding new members. New members will be added, specific to employed persons. The body of the printPersonInfo method must be changed because now there is more information to display.
Constructors and Inheritance

When you create an inherited class, its constructor will be automatically executed, but its parent's constructor does not get called. To execute the parent constructor, you have to call it explicitly within a subclass constructor with

parent::ClassName()


or

parent::__construct()


Example 17.10.

Code View: Scroll / Show All

   <?php
1  class Computer { // Parent/base/super class
2     private $password; // Is visible in this class
3     protected $userId; // Is visible in this class and subclass
4     public $printer;   // Is visible everywhere in the script

5     function __construct(){
          echo "Parent constructor just called.\n<br>";
          $this->userId="willie";
          $this->password="UrOKhi5";
      }
   }
   // Extend the computer class
6  class Laptop extends Computer{    // Child/derived/subclass
7      public $brand;
       public $weight;
8      private $password="LetMeIn2";

9      function __construct($brand,$weight){ // Subclass constructor
10         parent::__construct();  // Call to parent constructor
           echo "Child constructor just called.\n<br>";
11         $this->brand=$brand;    // New properties for the child
           $this->weight=$weight;
       }
   }
       // User of the class
12     $pc=new Computer();
13     $portable = new Laptop("Sonie","3.5");
14     $pc->printer="LazerBeam"; //direct access ok
       $portable->printer="Daisy";
15     // echo "$portable->password<br>"; // Fatal error
       //  echo "$pc->password<br>";   // Fatal error
       echo "<pre>"; // Get publicly available properties
16     print_r(get_object_vars($pc));
       print_r(get_object_vars($portable));
       echo "</pre>";
   ?>

					  


Explanation

1	The Computer class is declared. It represents the parent class.
2	The first property in this class is marked private. The $password variable will not and should not be available outside the class. A new computer object will have its own private password.
3	The $userId property is declared protected. It is visible and accessible within this class and if this class has any subclasses, they will inherit this property, but the subclass will not be able to use it anywhere outside its class and it will not be able to use its own methods to manipulate the $userId. The subclass can only access the protected variable through the public methods of the parent Computer class. (However, the subclass can define its own property called $userId that is not related to this one. See "Overriding Methods" on page 766.)
4	The public property, $printer, is available anywhere within the script.
5	The contructor is defined for this class. The user ID and password are initialized.
6	Now the Computer class is going to be "extended" to include a child or subclass, called Laptop. The new class is just an extension of its parent. It can add more features to the parent. For example, a laptop might be more concerned with weight and portability issues, it is priced differently, it needs a carrying case, and so on. The user might not change, but the laptop will have its own private password.
7	New property variables are created for the laptop computer.
8	The $password variable is marked private. It is not the same $password as in the parent, but a separate and private property of the laptop.
9	The laptop defines its own constructor.
10	The Laptop class calls its parent's constructor. Otherwise, any variables set in the parent's constructor will not be made part of this class.
11	The new properties for the laptop are initialized.
12	The user of the Computer class creates a new object, called $pc.
13	The user then creates a new object called $portable from the Laptop class that inherits from the Computer class. The user does not really know this. He or she creates the objects for the Laptop class the same way he or she creates them from the Computer class.
14	A printer is assigned to the object's printer property. Because the property was declared public, this is okay, because public properties are available outside the class.
15	These lines were commented out because they produced a fatal error. You cannot access private variables from outside either parent or child class, or you get a fatal error:

Fatal error: Cannot access private property laptop::$password in

C:\wamp\www\exeplee\obbectt\inner..hp on line 36

Fatal error: Cannot access private property computer::$password in

C:\wamp\www\emppes\\bjeets\\nhee.phh onnlinn 37
16	The get_object_vars() function returns a list of public properties for each class. The print_r function displays these properties, as shown in Figure 17.13.

Figure 17.13. Display public properties for the parent and child class.


17.2.10. Overriding Methods

Overriding is when you give the a member of a subclass the same name as its corresponding property or method in the parent class. If, for example, you have a value for a serial number property in the parent class, in the subclass, you might want a different serial number for the new product that was derived from its parent. You might also want to create your own "display" method in the child rather than use the one in the parent class providing a different functionality. By using the same name for the members of the inherited class that you used in the parent class, you are overriding the operations in the parent class.
Example 17.11.

Code View: Scroll / Show All

   <?php
   // Define the parent or super class
1  class Person {
      public $name;
      public $address;
      public $phone;
      // Define the methods
      function printPersonInfo(){
          echo "<hr><b>Person Info</b><br>";
          echo $this->name . "<br>\n";
          echo $this->address . "<br>\n";
          echo $this->phone . "<br>\n";
      }
   }
2  class EmployedPerson extends Person {
3     public $occupation;
4     public $company_name;
5     public $business_phone;

6     function printPersonInfo() // overriding
      {
7         parent::printPersonInfo();
8         echo $this->occupation . "<br>\n";

9         echo $this->company_name . "<br>\n";
10        echo $this->business_phone . "<br>\n";
      }
   }

11 $kid = new Person();
   $kid->name = "Jimmy";
   $kid->address = "12 Elm Street";
   $kid->phone = "555-5555";
12 $adult = new EmployedPerson();
13 $adult->name = "Jimmy's Father";
14 $adult->address = "12 Elm Street";
15 $adult->phone = "555-5555";
16 $adult->occupation = "Programmer";
17 $adult->company_name = "Software Developer, Ltd.";
18 $adult->business_phone = "444-4444";

19 $kid->printPersonInfo();
20 $adult->printPersonInfo();

   ?>

					  


Explanation

1	First we declare the class Person. In this example, we extend the class. By doing so, Person will become the parent or super class.
2	Class EmployedPerson will contain all the members of the class Person. EmployedPerson is the child or subclass of the Person class, its parent. The PHP keyword extends defines this relationship.
3–5	These are the new variables specific to EmployedPerson. Note the name, phone, and address properties are available to the EmployedPerson. They were inherited from the Person class.
6	The EmployedPerson also inherits the function printPersonInfo() from the Person class. However, now we want to redefine the behavior of this child class to include added functionality. This process is called overriding the method.
7	In this line we call the parent's function printPersonInfo(). The keyword parent in PHP refers to the class that is the parent to the current class, in this case Person. In other words, we are overriding the original implementation of the parent's method by first calling it and then adding some new statements.
8–10	This is where the new variables specific to the child class are added to the printPersonInfo() method.
11	A new object, called $kid, of class Person is created.
12	Next, another object, called $adult, of class EmployedPerson is created.
13–18	The properties for the $adult object are set.
19	We call Person's printPersonInfo() function.
20	We call EmployedPerson's printPersonInfo() function. This function will print differently then the Person function because there is more data to print out.

17.2.11. Protected Access

When a class member is preceded with the private access modifier, it is visible only within the class where it was created. If you try to access it directly from outside the class, you will receive an error message such as:

Fatal error: Cannot access private property computer::$password in . . .

If you call a class method from a class with private data, its private data will be visible, but if you call a method defined in a derived child class, the private data is not visible. If a private property is declared in a child class with the same name as a private property in its parent, it is unrelated to the parent's property. It is a separate variable in its own right.

If a class member is protected, then it is visible within a subclass; that is, it is inherited by the subclass and treated in the subclass like a private member but cannot be accessed outside the subclass. It can be accessed in the child class through the public methods defined in the parent and for methods defined within the child.

Fatal error: Cannot access protected property computer::$userId

If the class member is public, it is visible throughout the entire script and can be accessed directly from anywhere. In the object-oriented world you normally access private and protected data through public methods. It is, however, also possible to create private and protected methods.

Note that when you try to get or set the value of the private property of a parent class from within the subclass, instead of getting an error message, you get nothing. You are simply ignored.

Example 17.12.

Code View: Scroll / Show All

   <html><head><title>Private, Protected, Public</title>
   </head>
   <body bgcolor="lavender">
   <font face="ariel" size=+1>
   <h1>Private, Protected, Public</h1>
   <?php
1  class computer {
2     private $password;  // Visible only within this class
3     protected $userId;  // Visible within this class and subclass
4     public $printer;    // Visible anywhere in the script

5     function __construct() {  // Parent's constructor
         print "In the parent constructor.\n<br>";
         $this->userId = "willie";     // protected
         $this->password = "urAok5";   // private
      }
6     function setUserId($userId){
          $this->userId=$userId;
      }
7     function getUserId() {
          return $this->userId;
      }
8     private function setPassword($password){  // private method
          $this->password=$password;
      }
9     private function getPassword(){
          return $this->password;
      }
   }

10 class Laptop extends Computer{

11    public $model;
      public $weight;
12    private $password;

13    function __construct() { // Laptop's constructor
          echo "In the child's constructor\n<br>";
14        parent::__construct();
          // Inherited
15        echo "Inherited user name? ". $this->userId, "\n<br>";
          // Not inherited
          echo "Inherited password? ". $this->password, "\n<br>";
16        $this->brand=$brand;
          $this->weight=$weight;
      }
17    function setPassword($password){
          $this->password=$password; }
18    function getPassword(){
          return $this->password;
      }
   }

      // Class user
19    $pc=new Computer();  // Create two new objects
20    $portable = new Laptop();

21    $portable->setPassword("letmein2");
22    $pc->printer="Lazerboy"; // Direct access okay
      $portable->printer="Daisy";
      // echo $pc->userId;     // Error: Can't access directly
23    echo "<br>My Laptop username is ", $portable->getUserId(),
            "\n<br>";
24    echo "My pc username is ", $pc->getUserId(), "\n<br>";
      // echo "My pc password is ", $pc->getPassword(), "\n<br>";
25    echo "My Laptop password is ", $portable->getPassword(),
         "<br>";
26    echo "My pc printer is ", $pc->printer, "\n<br>";
      echo "My Laptop printer is ", $portable->printer, "<br>";
   ?>
   </body>
   </font>
   </html>

					  


Explanation

1	A class called computer is declared.
2	The access designator private makes the $password property visible only within this class.
3	The protected access designator makes the $userId property available in this class and any subclasses; that is, it is inherited.
4	public scope makes the $printer property available anywhere in the script. This is the default scope.
5	The parent's constructor function is called when the object is created. Properties are assigned to the object.
6–7	These are the setter and getter functions typically used to provide access to class members.
10	The laptop class is a subclass of the computer class.
13	A constructor method for the laptop class is defined.
14	Because the parent's constructor is not automatically called, we are calling it here. The keyword parent is followed by the scope resolution operator, ::, and the method that will be called, __construct().
15	The variable $userId was designated protected in the parent class. It is visible within this inherited class. The password property was designated as private in the parent class and is not visible here in the inherited class. You can only access this variable through public methods provided in the parent.
16	New properties are defined for the laptop class. It "extends" the computer class.
19	Now we are outside the boundaries of both the parent and the subclass. A new instance of the computer class is created, an object named $pc.
20	An instance of the laptop class is created, an object name $portable.
22	Public properties are directly accessible throughout the script. A value is being assigned to the laptop object's printer property.
23	The userId is a protected property. It is visible in both the parent and the subclass.
24	The object of the parent class, computer, can get its private property as long as it accesses it through its public method.
25	The object of the inherited class, laptop, cannot get the private property of its parent even with the getter method.
26	Both objects can access their printers because the printer property is public.

Figure 17.14. Inheritance and visibility with private, protected, and public variables.

17.3. Some PHP 5 Object Features

PHP 5 provided a number of new features for object-oriented programmers, some of which are discussed here and some of which are beyond the scope of this chapter. Not included are some of the magic methods, cloning, abstraction, iterators, and interfaces.
17.3.1. final Classes and Methods

A class that has been declared final cannot be inherited. Methods that have been declared as final can be used within subclasses, but they cannot be overridden. Let's consider an example next.
Example 17.13.

   <?php
1  class Computer{
2     private $serial_number;
3     final function setSerialNumber($serial_number) {
          $this->serial_number=$serial_number;
      }
   }
4  class Laptop extends Computer {
5     private $new_serial_number;
6     function setSerialNumber() {
7         $this->new_serial_number=$new_serial_number;
      }
   }
8  $portable->new Laptop();
   $portable -> setSerialNumber("abc!@$#");

   ?>


(Output)

Fatal error: Cannot override final method computer::setSerialNumber()
in C:\wamp\www\exemples\objects\...


Explanation

1	The Computer class is declared. It will be the parent class in this example.
2	A private property member called $serial_number is declared for this class.
3	The setSerialNumber() method has been declared final, meaning that a child class cannot redefine or override it. This prevents a subclass from changing the serial number.
4	The Laptop class is a subclass of the Computer class.
5	The child class declares a private property called $new_serial_number.
6	The child class declares a method name setSerialNumber.
7	The purpose of this class is to override the parent method of the same name and provide a new private serial number.
8	A fatal error occurs when the method setSerialNumber() in the child class is called. A method that is declared final cannot be overridden.

17.3.2. Static Members

Static members are new with PHP 5. They are properties or methods that do not require an instance of an object to be used. Static members are also called class members because they are created by and for the class as a whole. They are like global variables in any other PHP script in that they are available throughout the class. You can access a static property or method with the name of the class or the special class keyword self.
Example 17.14.

   <?php
   class House{
1     static $houseCount;
      private $owner; public $address;

      function __construct($owner,$address){
2         self::$houseCount++;
          $this->owner=$owner;
          $this->address=$address;
          echo "Constructor initializing a new house ";
          echo "in the ", get_class($this)," class.\n<br>";
3         echo "So far, we have built ", self::$houseCount,
             " houses.<br>";
      }
   }
      // Using the class to create objects
4     $myHouse= new House("Joe","13 River Road");
      $yourHouse = new House("Brad","1 Roundabout Drive");
      $theirHouse=new House("Mary", "5 Outthere Street");
   ?>


Explanation

1	In the House class, a static property is declared with the static keyword.
2	The static variable is not associated with a specific object, only the class, which can be referenced with self and two colons. Each time the constructor method is called, the value of the static variable will be incremented by 1. We are keeping track of the number of objects that are created.
3	The value of the static variable is retrieved.
4	The next three lines create three new houses. Each time the constructor for a new house is invoked, the static variable will be incremented, as shown in the output of this program in Figure 17.15.

Figure 17.15. Static property.


17.3.3. Class Constants

Rising gas prices, taxes, and death are constants. You can create global constants by using PHP's define() function (see Chapter 4, "The Building Blocks"). PHP 5 allows you to encapsulate constants within a class. They are not objects and cannot be referenced with $this. Constants represent values that are not expected to change and can be used by the class as a whole. Such values might be the document root of this server, the database host and password, and so on. Once declared, constants cannot be changed by the program. They are declared with the const keyword and are referenced with the class name or self and the scope resolution operator followed by the name of the constant.
Example 17.15.

Code View: Scroll / Show All

   <?php
   class House{
1     const TAX_COLLECTOR="Dick Scrooge";
2     const COUNTY="Butte";
      private $owner;
      public $address;
      function __construct($owner,$address){
          $this->owner=$owner;
          $this->address=$address;
          echo "Constructor initializing a new house ";
          echo "in the ", get_class($this)," class.\n<br>";
      }
3     function Tax_info(){
4         echo "The tax collector for ", self::COUNTY,
               " is ", self::TAX_COLLECTOR,".< br>";
          // could use House::County or House::TAX_COLLECTOR
      }
   }
      // Using the class to create objects
      $myHouse= new House("Joe","13 River Road");
      $yourHouse = new House("Brad","1 Roundabout Drive");
      $theirHouse=new House("Mary", "5 Outthere Street");
5     House::Tax_info();
   ?>

					  


Explanation

1, 2	Two constants for this class are defined. These are values that are not expected to change for any instance of the class. These are called class constants. Outside the class constants are declared with the define() function (see Chapter 4, "The Building Blocks").
3	A class function called Tax_info() is declared.
4	The self:: syntax refers to the name of the current class. You also say House::County to mean the same thing. The value of the constants COUNTY and TAX_COLLECTOR are retrieved and printed. They are the same no matter how many house objects you create. See the output in Figure 17.16.
5	The Tax_info() function is called. It does not require an instance of the class. It behaves the same for all objects. The House:: syntax tells PHP to go to the House class and call the function Tax_info().

Figure 17.16. Class constants in a class.


17.3.4. Reusing a Class

The following example starts with a class that will be used to create a guest book. The class is stored in a separate file that will be included in a PHP self-processing form file. The information for the guest book will come from an HTML form. After the user fills out the fields in the HTML form, PHP will extract the form data. A new GuestBook object is created and the input from the form is assigned as properties to the object. After all the information is assigned to the object, the class methods will display the data in the guest book and send it to a text file. This is a very simple form (see Figure 17.17) and a very simple class. The form consists of text fields and a submit button. The class consists of private property variables and setter and getter access methods. You could create a constructor and destructor for the class, later extend the class to include e-mail and cell phone data, save the information in a database rather than a text file, and certainly add error checking, form validation with regular expressions. The basic class can be used and reused, the class details can be changed, but the user should not be concerned about internal changes to the class as long as the interface remains the same.

Figure 17.17. The HTML form.

[View full size image]

Example 17.16.

Code View: Scroll / Show All

   (The Class File)
   <?php
1  class GuestBook{
2     protected $name;
      protected $address;
      protected $phone;
      protected birthday;
      private $file;
      // Setters
3     function setName($name){
          $this->name=$name;
      }
      function setAddress($address){
          $this->address=$address;
      }
      function setPhone($phone){
          $this->phone=$phone;
      }
      function setBirthday($birthday) {
          $this->birthday=$birthday;
      }
      function setFile($file){
          $this->file=$file;
      }
      // Getters
4     function getName($name){
          return $this->name;
      }
      function getAddress($address){
          return $this->address;
      }
      function getPhone($phone){
          return $this->phone;
      }

      function getBirthday($birthday){
          return $this->birthday;
      }
      function getFile($file){
          return $this->file;
      }
5     function showGuest(){
          echo "$this->name<br>";
          echo "$this->address<br>";
          echo "$this->phone<br>";
          echo "$this->birthday<br>";
      }
6     function saveGuest(){
7         $outputstring=$this->name . ":" .$this->address.":"
              .$this->phone.":". $this->birthday. "\n";
8         $path="$_SERVER[DOCUMENT_ROOT]/../guests/$this->file";
9         @ $fh = fopen("$path", "ab");
10        if (! $fh){
             $fh = fopen("$path", "wb");
          }
11        fwrite($fh, $outputstring, strlen($outputstring));
          fclose($fh);
          echo "Data saved in $path<br>";
      }
   }
   ?>

					  


Explanation

1	The class called GuestBook is declared in a file called guest_book.class.
2	The class variables (members) are defined. They are made protected members, meaning they are available to the class where they are created and to any subclasses.
3	This is where the setter methods are defined for the class—object-oriented functions that will assign values to the properties of the class.
4	This is where the getter methods are defined for the class—methods used to retrieve values from the properties of the class.
5	The method called showGuest() is used to display all the properties of the class.
6	The method called saveGuest() is declared. This method will open the guest book file and save a string of guest information to the file.
7	The properties for a new guest entry are concatenated into a string called $ outputstring.
8	The $path variable is assigned the full path to guestbook.txt, the file in this example, where the guest information is stored. The file is located in a directory or folder outside the server's document root to prevent outsiders from accessing it.
9	The file is opened for appending and a handle to it returned to $fh. If there is a problem in opening the file (e.g., it does not exist), the error message is suppressed by prepending the statement with an @ sign.
10	If the file did not exist, it will be created and opened for writing.
11	This is where the guest data is sent to the guestbook.txt file.

Example 17.17.

Code View: Scroll / Show All

----------------------------------------------------------------------
(The HTML Form and Class User)
   include("header.inc");
1  include("guest_book.class");
   if ( isset($_POST['submit'])){   // Was the form submitted?
2     extract($_POST);              // Get the form data
      /* Use the AddressBook Class */
3     $entry= new GuestBook();      // Instantiate the class
4     $entry->setName($your_name);  // Assign the properties
      $entry->setAddress($your_address);
      $entry->setPhone($your_phone);
      $entry->setBirthday($your_bd);
      $entry->setFile($your_file);
5     $entry->showGuest();          // Call the class methods
6     $entry->saveGuest();
   }
   else{ ?>
7      <form action="<?php echo $_SERVER['PHP_SELF']; ?>"
                method="POST">
       <div align="center">
       <font face="arial" size=+1>
       <table cellspacing="1" cellpadding="1" border="0">
8         <tr><td>Enter your name:</td>
             <td><input type="text" size=50 name="your_name"></td>
          <tr>
          <tr><td>Enter your address:</td>
             <td><input type="text" size=50 name="your_address"></td>
          </tr>
          <tr><td> Enter your phone:</td>
             <td><input type="text" size=20 name="your_phone"></td>
          </tr>
          <tr><td>Enter your birthday:</td>
             <td><input type="text" size=12 name="your_bd"></td>
          </tr>
9         <tr><td><input type=hidden name="your_file"
                       value="guestbook.txt">
             </td>
             <td><input type="submit" name="submit"
                       value="Submit Entry"></td>
          </tr>
          <tr><td></td>
             <td><input type=reset value="Clear"></td>
          </tr>
       <table>
       </form>
       </div>
       </html>
       <?php
       }
10     include("footer.inc");
   ?>

					  


Explanation

1	The header file (an HTML file to produce a centered block of text at the top of the page) and the class file (containing the GuestBook class) are "included," that is, made part of this script. (The header file was shown in Chapter 10, "More on PHP Forms.")
2	If the form has already been submitted by the user, PHP extracts the form data and assigns it to variables of the same name.
3	A new GuestBook object is created and a reference to it is assigned to $entry.
4	The name of the new guest is set here. The information that came in from the form was assigned to $your_name.
5	The showGuest() method retrieves and displays the data that was collected from the form.
6	The saveGuest() method is called. It saves the guest information in the file guest_book.txt.
7	If the form has not been submitted, the PHP else block is executed including the HTML form starting here. It is a self-processing form.
8	The user input devices are set up within an HTML table.
9	This hidden field contains the name of the file where the guest information is stored.
10	The footer.inc file is included here. It is an HTML file that produces copyright information and "Personal Guest Book" at the bottom of the page.

17.4. Chapter Summary

This chapter introduced you to OOP using PHP. Its purpose was to familiarize you with common terms used in OOP and how to apply basic concepts. Because this type of programming tries to emulate real-world situations, the examples were to help you visualize OOP by providing real-world types of objects, such as computers, houses, bank accounts, and people. OOP is a way of thinking about a program. Knowing the basic concepts is just the beginning. Like any art, it takes time to create good design, error handling, modularity, and mastery, but the goal is to be able to write elegant code to solve complex problems.
17.4.1. What You Should Know

Now that you have finished this chapter you should be able to answer the following questions, and know how to put together all the elements discussed into a working application:

1.	How would you define a class and its members?
2.	How would you create an object from a class?
	
3.	Define private, public, and protected properties.
4.	How would you implement inheritance?
5.	What is encapsulation?
6.	How could you use magic methods?
7.	What are constructors and destructors?
8.	How would you override a property or method?
9.	How would you provide information hiding using setters and getters?
10.	How do you create static properties and methods?
11.	How do you create final methods?
12.	How do you create class constants?

Chapter 17 Lab

1.	

   1.

      Create a clock object. It will have three properties: seconds, minutes, and hours.
   2.

      Write two methods, setTime() to set the current time, and displayTime() to display the time in the browser (like a digital clock).

2.	Create a circle object and a method that will calculate its circumference.
3.	

   1.

      In the Chapter 14 Lab, you created a student table for the MySQL school database. Write a PHP program that will add, delete, and update entries in the student table in the school database. You will create (use __construct()) a student object using the field names from the database table as properties. The methods will be add_Student(), drop_Student(), update_Student(), and displayStudent(). Use MySQL functions to retrieve the records for a student from the database.
   2.

      Create an HTML form to provide the user with a selection of functions from which to choose. If, for example, he or she selects "Add a new student", the PHP script will create another form to ask for the student information; and after the form information is completed, the PHP script will validate all the fields, and then use a MySQL function to add the new student to the student table in the database. The user should be able to add, delete, update, or display any number of students. Use a session to maintain state between operations.
      
      
