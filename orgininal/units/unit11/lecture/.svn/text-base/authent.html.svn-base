<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta name="generator" content="HTML Tidy, see www.w3.org">
  <title>Basics of Authentication</title>
  <link href="../../../css/basic.css" rel="stylesheet" type="text/css">
  <script type="text/javascript" language="JavaScript">
<!--
function putSemester() {
var today=new Date();
var thisMonth=today.getMonth()+1;
var thisYear=today.getFullYear();
if(thisMonth <=6) {
return "Spring, " + thisYear;
}
else {
return "Fall, " + thisYear;
}
}//-->
  </script>
  <style type="text/css">
<!--
.bgStripes {
background-image:url(../../../images/Xstripes.gif);
background-attachment: fixed;
}
body {
background-color:white;
}
strong {
font-family: Arial, Helvetica, sans-serif;
}
.table1 {
font-family:Arial, Helvetica, sans-serif;
font-size: small;
}
.table2 {
font-family:Arial, Helvetica, sans-serif;
font-size: small;
text-align:center;
}
td.cen {
text-align:center;
}
.small_title {
font-family: Arial, Helvetica, sans-serif;
font-size:x-small;
font-weight:bold;
}
.med_title {
font-family: Arial, Helvetica, sans-serif;
font-size:medium;
font-weight:bold;
text-align:center;
color:darkblue;
}
-->
  </style>
</head>
<body style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<table class="bgStripes" border="0" width="100%">
  <tbody>
    <tr name="firstRow">
      <td valign="top" width="80">
      <p class="small_title">
      <script type="text/javascript">
<!--
document.write(putSemester());
-->
</script></p>
</td>
<td>
<p class="med_title"><span
 style="color: darkblue; font-size: medium; font-weight: bold;">
PHP Web Development with MySQL</span></p>
</td>
<td align="right" valign="top" width="80">
<p class="small_title">
3 Credits</p>
</td>
</tr>
<tr>
<td colspan="3" height="10">
<p class="small_title" align="center">152-166</p>
</td>
</tr>
</tbody>
</table>
<!--The heading for the slides --> <br>
<table class="headTable1" border="0">
  <tbody>
    <tr>
      <td width="100"><a href="identify.html"><img alt=""
 src="../../../images/btn_lArrow.gif" border="0"></a><a
 href="index.html"><img alt="" src="../../../images/btn_upArrow.gif"
 border="0"></a><a href="secure.html"><img alt=""
 src="../../../images/btn_rArrow.gif" border="0"></a></td>
<td>
<p>
Basics of Authentication
</p>
</td>
</tr>
</tbody>
</table>
<br>
<div class="disp1">
<ul class="slidesUl1">
<li>
<p>
Using Basic Authentication</p>
<p>
Fortunately, authenticating users is a common task, so
authentication facilities are built into HTTP. Scripts or web servers
can request authentication from a web browser. The web browser is then
responsible for displaying a dialog box or similar device to obtain
required information from the user.</p>
<p>
Although the web server requests new authentication details for
every user request, the web browser does not need to request the user's
information for every page. The browser generally stores this information for
as long as the user has a browser window open and automatically resends
them to the web server as required without user interaction.</p>
<p>
This feature of HTTP is called "basic authentication". You can
trigger basic authentication using PHP or using mechanisms built into
your web server. We look first at the PHP method, then the Apache
method, and finally the IIS method.</p>
<p>
Basic authentication transmits a user's name and password in plain text,
so it is not very secure. HTTP 1.1 contains a more secure method known as
"digest authentication", which uses a hashing algorithm (usually MD5) to
disguise the details of the transaction. Digest authentication is
supported by many web servers and most current-version web browsers.
Unfortunately, as with many recently implemented features, there are
many older browsers still in use that do not support digest
authentication and a version of the standard included in Microsoft IE
and IIS that is not compatible with non-Microsoft products.</p>
<p>
In addition to being poorly supported by installed web browsers,
digest authentication is still not very secure.
Both basic and digest authentication provide a low level
of security. Neither gives the user any assurance that (s)he is dealing
with the machine (s)he intended to access. Both might permit a cracker to
replay the same request to the server. Because basic authentication
transmits the user's password as plain text, it allows any cracker
capable of capturing packets to impersonate the user for making any
request.</p>
<p>
Basic authentication provides a (low) level of security similar to that
commonly used to connect to machines via Telnet or FTP, transmitting
passwords in plain text. Digest authentication is somewhat more secure,
encrypting passwords before transmitting them.</p>
<p>
When you combine basic authentication with SSL and digital certificates,
all parts of a web transaction can be protected by strong security.
However, for many situations, a fast, but relatively insecure, method
such as basic authentication is appropriate.</p>
<p>
Basic authentication protects a named realm and requires users to provide
a valid username and password. Realms are named so that more than one realm
can be on the same server. Different files or directories on the same server can
be part of different realms, each protected by a different set of names
and passwords. Named realms also let you group multiple directories on
the one host or virtual host as a realm and protect them all with one
password.</p>
</li>
<li>
<p>
Using Basic Authentication in PHP</p>
<p>
PHP scripts are generally cross-platform, but using basic authentication relies
on environment variables set by the server. For an HTTP authentication script
to run on Apache using PHP as an Apache module or on IIS using PHP as an ISAPI
module, it needs to detect the server type and behave slightly
differently. The script <a href="../examples/http_php.html">http.php</a>
will run on both servers.</p>
<p>
The code above acts similarly to the previous listings in
this unit. If the user has not yet provided authentication information,
it will be requested.
If (s)he has provided incorrect information, she is given a rejection
message. If she provides a matching name-password pair, she is presented
with the contents of the page.</p>
<p>
In this case, the user will see an interface somewhat different from the
previous listings. This script does not provide an HTML form for login
information. The user's browser presents him/her with a dialog box.
Some people see this as an improvement; others would prefer to have complete
control over the visual aspects of the interface.</p>
<p>
Because the authentication is being assisted by features built into the browser,
the browser chooses to exercise some discretion in how failed authorization
attempts are handled. Internet Explorer lets the user try to
authenticate three times before displaying the rejection page. Netscape
Navigator lets the user try an unlimited number of times, popping up a
dialog box to ask, "Authorization failed. Retry?" between attempts.
Netscape displays the rejection page only if the user clicks Cancel.</p>
<p>
As with the code given in <b>secret.php</b> and <b>secretdb.php</b>,
you could include this code in pages you wanted to protect or
automatically prepend it to every file in a directory.</p>
</li>
<li>
<p>
Apache's .htaccess Basic Authentication</p>
<p>
You can achieve similar results to the <b>http.php</b> script without
writing a PHP script.</p>
<p>
The Apache web server contains a number of different authentication modules
that can be used to decide the validity of data entered by a user.
The easiest to use is <b>mod_auth</b>,
which compares name-password pairs to lines in a text file on the server.</p>
<p>
To get the same output as the preceding script, you need to create two separate
HTML files: one for the content and one for the rejection page. We skipped some HTML
elements in the previous examples but really should include <code>&lt;html&gt;</code>
and <code>&lt;body&gt;</code> tags when generating HTML.</p>
<p>
The next code listing, named <b>content.html</b>,
contains the content that authorized users see. After that, <b>rejection.html</b>
contains the rejection page. Having a page to show in case of errors is
optional, but it is a nice, professional touch if you put something
useful on it. Given that this page will be shown when a user attempts
to enter a protected area but is rejected, useful content might include
instructions on how to register for a password, or how to get a
password reset and emailed if it has been forgotten.</p>
<p>Listing: content.html<br>
Sample Content</p>
<blockquote><code><small>
&lt;html&gt;&lt;body&gt;<br>
&nbsp;&lt;h1&gt;Here it is!&lt;/h1&gt;<br>
&nbsp;&lt;p&gt;I bet you are glad you can see this secret page.&lt;/p&gt;<br>
&lt;/body&gt;&lt;/html&gt;<br>
</small></code></blockquote>
<p>
Listing: rejection.html<br>
Sample 401 Error Page</p>
<blockquote><code><small>
&lt;html&gt;&lt;body&gt;<br>
&nbsp;&lt;h1&gt;Go Away!&lt;/h1&gt;<br>
&nbsp;&lt;p&gt;You are not authorized to view this resource.&lt;/p&gt;<br>
&lt;/body&gt;&lt;/html&gt;<br>
</small></code></blockquote>
<p>
There is nothing new in these files. The interesting file for this
example is in the next listing. This file needs to be called <b>.htaccess</b>
and will control accesses to files and any subdirectories in its directory.</p>
<p>
Listing: .htaccess<br>
An .htaccess File Can Set Many Apache Configuration Settings, Including Activating
Authentication</p>
<blockquote><code><small>
ErrorDocument 401 /unit11/rejection.html<br>
AuthUserFile /home/book/.htpass<br>
AuthGroupFile /dev/null<br>
AuthName "Realm-Name"<br>
AuthType Basic<br>
require valid-user<br>
</small></code></blockquote>
<p>
The listing above is an <b>.htaccess</b>
file to turn on basic authentication in a directory. Many settings can
be made in an <b>.htaccess file</b>, but the six lines in this example all
relate to authentication.</p>
<p>
The first line:</p>
<blockquote><code>
ErrorDocument 401 /unit11/rejection.html<br>
</code></blockquote>
<p>
tells Apache what document to display for visitors who fail to
authenticate (HTTP error number 401). You can use other
<code>ErrorDocument</code> directives to provide your own pages for other
HTTP errors such as 404. The syntax is:</p>
<blockquote><code>
ErrorDocument error_number URL<br>
</code></blockquote>
<p>
For a page to handle error 401, it is important that the URL
given is publicly available. It would not be very useful in providing a
customized error page to tell people that their authorization failed if the
page is locked in a directory which they need to successfully authenticate to see.</p>
<p>
The line:</p>
<blockquote><code>
AuthUserFile /home/book/.htpass<br>
</code></blockquote>
<p>
tells Apache where to find the file that contains authorized
users' passwords. This file is often named <b>.htpass</b>, but
you can give it any name you prefer. It is not important what you call
this file, but it is important where you store it. It should not be
stored within the web tree (somewhere that people can download it via
the web server). A sample <b>.htpass</b> file listing is shown below.</p>
<p>
As well as specifying individual users who are authorized, it is possible to
specify that only authorized users who fall into specific groups may access
resources. We chose not to, so the line:</p>
<blockquote><code>
AuthGroupFile /dev/null<br>
</code></blockquote>
<p>
sets the <code>AuthGroupFile</code> to point to <code>/dev/null</code> , a
special file on Unix systems that is guaranteed to be null.</p>
<p>
Like the PHP example, to use HTTP authentication, you need to name the realm as
follows:</p>
<blockquote><code>
AuthName "Realm-Name"<br>
</code></blockquote>
<p>
You can choose any realm name you prefer, but bear in mind that
the name will be shown to your visitors. To make it obvious that the name
in the example should be changed, we named ours "Realm-Name".</p>
<p>
Because a number of different authentication methods are supported,
you need to specify which authentication method you are using.
Here, you use <code>Basic</code> authentication, as specified by
this directive:</p>
<blockquote><code>
AuthType Basic<br>
</code></blockquote>
<p>
You also need to specify who is allowed access. You could specify
particular users, particular groups, or as we have done, simply allow
any authenticated user access. The line:</p>
<blockquote><code>
require valid-user<br>
</code></blockquote>
<p>
specifies that any valid user is to be allowed access.</p>
<p>
Listing: .htpass<br>
The Password File Stores Usernames and Each User's Encrypted Password</p>
<blockquote><code>
user1:0nRp9M80GS7zM<br>
user2:nC13sOTOhp.ow<br>
user3:yjQMCPWjXFTzU<br>
user4:LOmlMEi/hAme2<br>
</code></blockquote>
<p>
Each line in the <b>.htpass</b> file contains a username, a colon,
and that user's encrypted password.</p>
<p>
The exact contents of your
<b>.htpass</b> file will vary. To create it, you use a small program called
<code>htpasswd</code> that comes in the Apache distribution.</p>
<p>
The <code>htpasswd</code> program is used in one of the following ways:</p>
<blockquote><code>
htpasswd [-cmdps] passwordfile username<br>
</code></blockquote>
<p>
or</p>
<blockquote><code>
htpasswd -b[cmdps] passwordfile username password<br>
</code></blockquote>
<p>
The only switch that you need to use is <code>-c</code> .
Using <code>-c</code> tells <code>htpasswd</code>
to create the file. You must use this for the first user you add. Be
careful not to use it for other users because, if the file exists,
<code>htpasswd</code> will delete it and create a new one.</p>
<p>
The optional <code>m , d , p ,</code> or <code>s</code>
switches can be used if you want to specify which encryption algorithm
(including no encryption) you would like to use.</p>
<p>
The <code>b</code> switch tells the program to expect the password as a
parameter rather than prompt for it. This feature is useful if you want to
call <code>htpasswd</code> noninteractively as part of a batch process,
but you should not use it if you are calling <code>htpasswd</code>
from the command line.</p>
<p>
The following commands created the file shown as our <b>.htpass</b> example above:</p>
<blockquote><code><small>
htpasswd -bc /home/book/.htpass user1 pass1<br>
htpasswd -b /home/book/.htpass user2 pass2<br>
htpasswd -b /home/book/.htpass user4 pass3<br>
htpasswd -b /home/book/.htpass user4 pass4<br>
</small></code></blockquote>
<p>
Note that <code>htpasswd</code> may not be in your path: If it is not, you
may need to supply the full path to it. On many systems, you will find it in the
<code>/usr/local/apache/bin</code> directory.</p>
<p>
This sort of authentication is easy to set up, but there are a few problems
with using an <b>.htaccess</b> file this way.</p>
<p>
Users and passwords are stored in a text file. Each time a
browser requests a file that is protected by the <b>.htaccess</b> file, the
server must parse the <b>.htaccess</b> file and then parse the password file,
attempting to match the username and password. Instead of using an
<b>.htaccess</b> file, you could specify the same things in your
<b>httpd.conf</b> file (the main configuration file for the web server).
An <b>.htaccess</b> file is parsed every time a file is requested.
The <b>httpd.conf</b> file is parsed only when the server is initially started.
This approach is faster, but means that if you want to make changes,
you need to stop and restart the server.</p>
<p>
Regardless of where you store the server directives, the
password file still needs to be searched for every request. This means
that, like other techniques we have looked at that use a flat file,
this would not be appropriate for hundreds or thousands of users.</p>
</li>
<li>
<p>
Basic Authentication in IIS</p>
<p>
Like Apache, IIS supports HTTP authentication. Apache uses the Unix approach
and is controlled by editing text files, and as you might expect,
selecting options in dialog boxes controls the IIS setup.</p>
<p>
Using Windows XP, you change the configuration of Internet Information Server 5
(IIS5) using the Internet Information Services. You can find this utility by
choosing Administrative Tools in the Control Panel.</p>
<p>
The Internet Information Services application looks something like a Windows
Explorer window. The tree control on the left side shows what services are running
on that machine. The one of interest here is the default website.
Within this website is a directory named <code>protected</code> . Inside
this directory is a file named <b>content.html</b>.</p>
<p>
To add basic authentication to the protected directory, right-click on it and
select Properties from the context menu. Using the Properties dialog,
you can change many settings for this directory. The two tabs of interest here
are Directory Security and Custom Errors. One of the options on the Directory
Security tab is Anonymous Access and Authentication Control. Clicking
this Edit button brings up the Authentication Methods dialog box.</p>
<p>
Within this dialog, you can disable anonymous access and turn on basic authentication.
With basic authentication enabled, only people who provide an appropriate
name and password can view files in this directory.</p>
<p>
To duplicate the behavior of the previous examples, you can also provide a page
to tell users that their authentication details were not correct. Closing the
Authentication Methods dialog box allows you to choose the Custom
Errors tab.</p>
<p>
The Custom Errors tab associates errors with error messages.
Here, you may store the same rejection file used earlier,
<b>rejection.html</b>. IIS enables you to easily provide a more specific error
message than Apache does, providing the HTTP error code that occurred and a
reason why it occurred. For error 401, which represents failed authentication,
IIS provides five different reasons. You could provide different
messages for each.</p>
<p>
That is all you need to do to require authentication for this
directory using IIS5. Like a lot of Windows software, it is easier to
set up than similar Unix software but harder to copy from machine to
machine or directory to directory. Accidentally setting it up in a way
that makes your machine insecure is also easy.</p>
<p>
The major flaw with IIS's approach is that it authenticates web
users by comparing their login details to accounts on the machine. If
you want to allow a user "john" to log in with the password
"password", you need to create a user account on the machine, or on a
domain, with this name and password. You need to be very careful when
you are creating accounts for web authentication so that the users have
only the account rights they need to view web pages and do not have
other rights such as Telnet access.</p>
</li>
<li>
<p>
Using mod_auth_mysql Authentication
</p>
<p>
As already mentioned, <code>mod_auth</code> is easy to set up with Apache and
is effective. Because it stores users in a text file, it is not really practical
for busy sites with large numbers of users.</p>
<p>
Fortunately, you can have most of the ease of mod_auth, combined with the speed
of a database by using <code>mod_auth_mysql</code>. This module works in much
the same way as mod_auth, but because it uses a MySQL database instead of a
text file, it can search large user lists quickly.</p>
<p>
To use it, you need to compile and install the module on your system or ask
your system administrator to install it.</p>
</li>
<li>
<p>
Installing mod_auth_mysql</p>
<p>
To use <code>mod_auth_mysql</code> , you need to set up Apache and MySQL
according to the instructions in appendices of the textbook for installing
PHP and MySQL, but add a few extra steps. You can find reasonable
instructions in the files <b>README</b> and <b>USAGE</b>, which are in the
<code>mod_auth_mysql</code> distribution, but they refer to previous versions'
behavior in some places. Here is a summary:</p>
</li>
</ul>
<blockquote>
<ol type="1">
<li class="row1">
Obtain the distribution archive for the module. You can always get
the latest version from:
<code>http://sourceforge.net/projects/mod-auth-mysql/</code></li>
<li class="row1">
Unzip and untar the source code.</li>
<li class="row1">
Change to the mod_auth_mysql directory, run <code>make</code> ,
and then <code>make install</code>. You may need to
change the install locations for MySQL in the <code>make</code> file (MakeFile).</li>
<li class="row1">
Add this line to <b>httpd.conf</b>:<br>
<blockquote><code>
LoadModule mysql_auth_module libexec/mod_auth_mysql.so<br>
</code></blockquote>
to dynamically load the module into Apache.</li>
<li class="row1">
Create a database and table in MySQL to contain authentication information.
It does not need to be a separate database or table; you can use an existing
table such as the <code>auth</code> database from the example earlier in this unit.</li>
<li class="row1">
Add a line to your <b>httpd.conf</b> file to give <code>mod_auth_mysql</code>
the parameters it needs to connect to MySQL. The directive will look like:<br>
<blockquote><code>
Auth_MySQL_Info hostname user password<br>
</code></blockquote>
</li>
</ol>
</blockquote>
<ul class="slidesUl1">
<li>
<p>
Did It Work?</p>
<p>
The easiest way to check whether your compilation worked is to see whether
Apache will start. To start Apache, if you have SSL support, type:</p>
<blockquote><code>
/usr/local/apache/bin/apachectl startssl<br>
</code></blockquote>
<p>
If you don't have SSL support, you can type:</p>
<blockquote><code>
/usr/local/apache/bin/apachectl start<br>
</code></blockquote>
<p>
If it starts with the <code>Auth_MySQL_Info</code> directive in the
<b>httpd.conf</b> file, <code>mod_auth_mysql</code> was successfully added.</p>
</li>
<li>
<p>
Using mod_auth_mysql</p>
<p>
After you have successfully installed the <code>mod_auth_mysql</code>
module, using it is no harder than using <code>mod_auth</code>.
Below is a sample <b>.htaccess</b> file that will authenticate users with
encrypted passwords stored in the database created earlier in this unit.</p>
<p>
Listing: .htaccess<br>
This .htaccess File Authenticates Users Against a MySQL Database</p>
<blockquote><code><small>
ErrorDocument 401 /unit11/rejection.html<br><br>
AuthName "Realm Name"<br>
AuthType Basic<br><br>
Auth_MySQL_DB auth <br>
Auth_MySQL_Encryption_Types MySQL <br>
Auth_MySQL_Password_Table authorized_users <br>
Auth_MySQL_Username_Field name <br>
Auth_MySQL_Password_Field password <br><br>
require valid-user <br>
</small></code></blockquote>
<p>
You can see that much of this file is the same as the previous sample
<b>.htaccess</b> file shown. You still specify an error document to display in
the case of error 401 (when authentication fails). You again specify
basic authentication and give a realm name. As in the previous case,
you allow any valid, authenticated user access.</p>
<p>
Because we are using <code>mod_auth_mysql</code> and did not want to use all
the default settings, we used some directives to specify how
this should work. <code>Auth_MySQL_DB , Auth_MySQL_Password_Table ,
Auth_MySQL_Username_Field  ,</code> and <code>Auth_MySQL_Password_Field</code>
specify the name of the database, the table, the username field, and the
password field, respectively.</p>
<p>
We included the directive <code>Auth_MySQL_Encryption_Types</code>
to specify that we want to use MySQL password encryption. Acceptable
values are <code>Plaintext , Crypt_DES ,</code> or <code>MySQL</code> .
<code>Crypt_DES</code> is the default and uses standard Unix DES-encrypted passwords.</p>
<p>
From the user perspective, this <code>mod_auth_mysql</code> example
will work in exactly the same way as the <code>mod_auth</code> example. (S)he
will be presented with a dialog box by her/his web browser. If (s)he
successfully authenticates, (s)he will be shown the content. If (s)he
fails, (s)he will be given the error page.</p>
<p>
For many websites, <code>mod_auth_mysql</code> is ideal. It is fast and
relatively easy to implement, and it allows you to use any convenient
mechanism to add database entries for new users. For more flexibility
and the ability to apply fine-grained control to parts of pages, you
might want to implement your own authentication using PHP and MySQL.</p>
</li>
<li>
<p>
Creating your own Custom Authentication</p>
<p>
In this chapter, we looked at creating our own authentication
methods including some flaws and compromises and using built-in
authentication methods, which are less flexible than writing your
own code. After you learn about session control in Unit 14, you
will be able to write your own custom authentication with fewer
compromises than in this unit.</p>
<p>
In the PHP and MySQL advanced course we develop a simple
user authentication system that avoids some of the problems we
faced here by using sessions to track variables between pages. Then we
apply this approach to a real-world project and see how it can be used
to implement a fine-grained authentication system.
</p>
</li>
</ul>
</div>
</body>
</html>
